<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-C0002">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5RHQV7');</script>
<!-- End Google Tag Manager -->
  <title>chipscopy.api.ila.ila_waveform &mdash; ChipScoPy 2024.1.1717698244 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5RHQV7" height="0" width="0" style="display:none;visibility:hidden" class="optanon-category-C0002"></iframe></noscript>
<!-- End Google Tag Manager --> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> ChipScoPy
          </a>
              <div class="version">
                2024.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../overview.html">ChipScoPy Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chipscopy_installation.html">ChipScoPy Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev_setup.html">Developer Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ChipScoPy Debug Core API Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ddr.html">DDR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ibert.html">IBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ila.html">ILA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory.html">Memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../noc.html">NocPerfmon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pcie.html">PCIe</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sysmon.html">SysMon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../vio.html">VIO</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Misc Classes &amp; Utility Functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../containers.html">Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../device.html">Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../report.html">Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../session.html">Session</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ChipScoPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
          <li><a href="../../api.html">chipscopy.api</a> &raquo;</li>
      <li>chipscopy.api.ila.ila_waveform</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for chipscopy.api.ila.ila_waveform</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2021-2022, Xilinx, Inc.</span>
<span class="c1"># Copyright (C) 2022-2023, Advanced Micro Devices, Inc.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">zipfile</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">asdict</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">TextIOBase</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">,</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pformat</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">zipfile</span> <span class="kn">import</span> <span class="n">ZipFile</span>

<span class="kn">from</span> <span class="nn">chipscopy.api.ila</span> <span class="kn">import</span> <span class="n">ILABitRange</span><span class="p">,</span> <span class="n">ILAProbeRadix</span>
<span class="kn">import</span> <span class="nn">chipscopy</span>
<span class="kn">from</span> <span class="nn">chipscopy.shared.ila_util</span> <span class="kn">import</span> <span class="n">bin_reversed_to_hex_values</span>
<span class="kn">from</span> <span class="nn">chipscopy.utils</span> <span class="kn">import</span> <span class="n">Enum2StrEncoder</span>


<div class="viewcode-block" id="ILAWaveformProbe"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveformProbe">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ILAWaveformProbe</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Probe location in a data sample.&quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of probe.&quot;&quot;&quot;</span>
    <span class="nb">map</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location string&quot;&quot;&quot;</span>
    <span class="n">map_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ILABitRange</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;List of bit ranges. See :class:`~chipscopy.api.ila.ILABitRange`&quot;&quot;&quot;</span>
    <span class="n">is_bus</span><span class="p">:</span> <span class="nb">bool</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;True for bus probes&quot;&quot;&quot;</span>
    <span class="n">bus_left_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Bus left index. E.g. 5 in probe ``counter[5:0]``&quot;&quot;&quot;</span>
    <span class="n">bus_right_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bus right index. E.g. 0 in probe ``counter[5:0]``&quot;&quot;&quot;</span>
    <span class="n">display_radix</span><span class="p">:</span> <span class="n">ILAProbeRadix</span> <span class="o">=</span> <span class="n">ILAProbeRadix</span><span class="o">.</span><span class="n">HEX</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Display radix, when exporting waveform data. Default is ILAProbeRadix.HEX&quot;&quot;&quot;</span>
    <span class="n">enum_def</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">enum</span><span class="o">.</span><span class="n">EnumMeta</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enum class defining {name:int} enum values, for this probe.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mr</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">mr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_range</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bus_range_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bus</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bus_left_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">bus_right_index</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bus_left_index</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bus_left_index</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bus_right_index</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="ILAWaveform"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ILAWaveform</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Waveform data, with data probe information.&quot;&quot;&quot;</span>

    <span class="n">width</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample bit width.&quot;&quot;&quot;</span>
    <span class="n">sample_count</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of data samples.&quot;&quot;&quot;</span>
    <span class="n">trigger_position</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Trigger position index, for each data window.&quot;&quot;&quot;</span>
    <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of samples in a window.&quot;&quot;&quot;</span>
    <span class="n">probes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ILAWaveformProbe</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dict of {probe name, waveform probe}   See :class:`ILAWaveformProbe`&quot;&quot;&quot;</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">bytearray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Waveform data.</span>

<span class="sd">    Samples are aligned on byte boundary. </span>

<span class="sd">    This formula can be used to read a bit from the data:</span>
<span class="sd">    ::</span>

<span class="sd">        bytes_per_sample = len(data) // sample_count</span>

<span class="sd">        def get_bit_value(data: bytearray, bytes_per_sample: int,</span>
<span class="sd">                          sample_index: int, data_bit_index: int) -&gt; bool:</span>
<span class="sd">            byte_value = data[sample_index * bytes_per_sample + data_bit_index // 8]</span>
<span class="sd">            mask = 1 &lt;&lt; (data_bit_index &amp; 0x7)</span>
<span class="sd">            return (byte_value &amp; mask) != 0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gap_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    None or 0, if the waveform has no gaps. </span>
<span class="sd">    If the value is &gt;0, one sample bit is reserved to indicate which samples are gaps,</span>
<span class="sd">    i.e. the samples with unknown values. &#39;gap_index&#39; gives the bit location within the sample data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">bytes_per_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_count</span>

    <span class="k">def</span> <span class="nf">get_window_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">)</span>

<div class="viewcode-block" id="ILAWaveform.set_sample"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.set_sample">[docs]</a>    <span class="k">def</span> <span class="nf">set_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="nb">bytearray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample may have more bytes than waveform samples have. Erase any gap bit.&quot;&quot;&quot;</span>
        <span class="n">sample_byte_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytes_per_sample</span><span class="p">()</span>
        <span class="n">copy_byte_count</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sample_byte_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">sample_byte_count</span> <span class="o">*</span> <span class="n">sample_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">copy_byte_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">copy_byte_count</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap_index</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">gap_byte_index</span><span class="p">,</span> <span class="n">gap_bit_index</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xFF</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gap_bit_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">gap_byte_index</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="ILAWaveform.export_waveform"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.export_waveform">[docs]</a>    <span class="k">def</span> <span class="nf">export_waveform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">export_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CSV&quot;</span><span class="p">,</span>
        <span class="n">fh_or_filepath</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TextIOBase</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
        <span class="n">probe_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_DEFLATED</span><span class="p">,</span>
        <span class="n">compresslevel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export a waveform in CSV, VCD or CITF format, to a file or in-memory buffer.</span>
<span class="sd">        By default, all samples for all probes are exported, but it is</span>
<span class="sd">        possible to select which probes and window/sample ranges for CSV/VCD formats.</span>

<span class="sd">        ================================ ======================== ==============================</span>
<span class="sd">        Argument/Parameter               Type                     Supported by Export Format</span>
<span class="sd">        ================================ ======================== ==============================</span>
<span class="sd">        export_format                    str                      CSV, VCD, CITF</span>
<span class="sd">        fh_or_filepath                   TextIOBase               CSV, VCD</span>
<span class="sd">        fh_or_filepath                   BytesIO                            CITF</span>
<span class="sd">        fh_or_filepath                   str                      CSV, VCD, CITF</span>
<span class="sd">        probe_names                      List[str]                CSV, VCD</span>
<span class="sd">        start_window                     int                      CSV, VCD</span>
<span class="sd">        start_sample_idx                 int                      CSV, VCD</span>
<span class="sd">        sample_count                     int                      CSV, VCD</span>
<span class="sd">        include_gap                      bool                     CSV, VCD</span>
<span class="sd">        include_gap                      bool                     CSV, VCD</span>
<span class="sd">        compression                      int                                CITF</span>
<span class="sd">        compresslevel                    int                                CITF</span>
<span class="sd">        ================================ ======================== ==============================</span>


<span class="sd">        Args:</span>
<span class="sd">            export_format (str):  Alternatives for output format.</span>

<span class="sd">                - &#39;CSV&#39; - Comma Separated Value Format. Default.</span>
<span class="sd">                - &#39;VCD&#39; - Value Change Dump.</span>
<span class="sd">                - &#39;CITF&#39; - ChipScoPy ILA Trace Format. Export of a whole ILA waveform to a compressed archive.</span>


<span class="sd">            fh_or_filepath (TextIOBase, BytesIO, str): File object handle or filepath string. Default is `sys.stdout`.</span>
<span class="sd">                If the argument is a file object, closing and opening the file is the responsibility of the caller.</span>
<span class="sd">                If argument is a string, the file will be opened and closed by the function.</span>

<span class="sd">            probe_names (Optional[List[str]]): List of probe names. Default &#39;None&#39; means export all probes.</span>
<span class="sd">            start_window_idx (int): Starting window index. Default is first window.</span>
<span class="sd">            window_count (Optional[int]): Number of windows to export. Default is all windows.</span>
<span class="sd">            start_sample_idx (int): Starting sample within window. Default is first sample.</span>
<span class="sd">            sample_count (Optional[int]): Number of samples per window. Default is all samples.</span>
<span class="sd">            include_gap (bool):  Default is False. Include the pseudo &quot;gap&quot; 1-bit probe in the result.</span>
<span class="sd">            compression: Default is zipfile.ZIP_DEFLATED. See zipfile.ZipFile at https://docs.python.org/.</span>
<span class="sd">            compresslevel: See zipfile.ZipFile at https://docs.python.org/.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;CITF&quot;</span><span class="p">:</span>
            <span class="n">export_compressed_waveform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fh_or_filepath</span><span class="p">,</span> <span class="n">compression</span><span class="p">,</span> <span class="n">compresslevel</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;VCD&quot;</span> <span class="ow">and</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;CSV&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;ILAWaveform.export() called with unknown export_format:&quot;</span><span class="si">{</span><span class="n">export_format</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
                <span class="s2">&quot;Supported export formats are VCD, CSV and CITF.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fh_or_filepath</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fh_or_filepath</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=</span><span class="mi">16384</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">export_waveform_to_stream</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">export_format</span><span class="p">,</span>
                    <span class="n">fh</span><span class="p">,</span>
                    <span class="n">probe_names</span><span class="p">,</span>
                    <span class="n">start_window_idx</span><span class="p">,</span>
                    <span class="n">window_count</span><span class="p">,</span>
                    <span class="n">start_sample_idx</span><span class="p">,</span>
                    <span class="n">sample_count</span><span class="p">,</span>
                    <span class="n">include_gap</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">export_waveform_to_stream</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">export_format</span><span class="p">,</span>
                <span class="n">fh_or_filepath</span><span class="p">,</span>
                <span class="n">probe_names</span><span class="p">,</span>
                <span class="n">start_window_idx</span><span class="p">,</span>
                <span class="n">window_count</span><span class="p">,</span>
                <span class="n">start_sample_idx</span><span class="p">,</span>
                <span class="n">sample_count</span><span class="p">,</span>
                <span class="n">include_gap</span><span class="p">,</span>
            <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">import_waveform</span><span class="p">(</span>
        <span class="n">import_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">filepath_or_buffer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an ILAWaveform object from a ChipScoPy ILA Trace Format (CITF) compressed archive.</span>
<span class="sd">        The archive must contain these two files:</span>

<span class="sd">            - waveform.cfg, waveform and probe meta information.</span>
<span class="sd">            - waveform.data, binary waveform samples.</span>

<span class="sd">        Args:</span>
<span class="sd">            import_format (str): Format &quot;CITF&quot; is supported.</span>
<span class="sd">            filepath_or_buffer (str, BytesIO): Filepath string or in-memory buffer.</span>

<span class="sd">        Returns (ILAWaveform):</span>
<span class="sd">            Waveform object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">import_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;CITF&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;import_waveform command called with import_format &quot;</span><span class="si">{</span><span class="n">import_format</span><span class="si">}</span><span class="s1">&quot;.&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; Only &quot;CITF&quot; format is supported.&#39;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">import_compressed_waveform</span><span class="p">(</span><span class="n">filepath_or_buffer</span><span class="p">)</span>

<div class="viewcode-block" id="ILAWaveform.get_data"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">probe_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_trigger</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">include_sample_info</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get probe waveform data as a list of int values for each probe.</span>
<span class="sd">        By default, all samples for all probes are included in return data,</span>
<span class="sd">        but it is possible to select which probes and window/sample ranges.</span>

<span class="sd">        Args:</span>
<span class="sd">            probe_names (Optional[List[str]]): List of probe names. Default &#39;None&#39; means export all probes.</span>
<span class="sd">            start_window_idx (int): Starting window index. Default is first window.</span>
<span class="sd">            window_count (Optional[int]): Number of windows to export. Default is all windows.</span>
<span class="sd">            start_sample_idx (int): Starting sample within window. Default is first sample.</span>
<span class="sd">            sample_count (Optional[int]): Number of samples per window. Default is all samples.</span>
<span class="sd">            include_trigger (bool): Include pseudo probe with name &#39;__TRIGGER&#39; in result. Default is False.</span>
<span class="sd">            include_sample_info (bool):  Default is False. Include the following pseudo probes in result:</span>

<span class="sd">              - &#39;__SAMPLE_INDEX&#39; - Sample index</span>
<span class="sd">              - &#39;__WINDOW_INDEX&#39; - Window index.</span>
<span class="sd">              - &#39;__WINDOW_SAMPLE_INDEX&#39; - Sample index within window.</span>

<span class="sd">            include_gap (bool):  Default is False. If True, include the pseudo probe &#39;__GAP&#39; in result. \</span>
<span class="sd">                                 Value 1 for a gap sample. Value 0 for a regular sample.</span>


<span class="sd">        Returns (Dict[str, List[int]]):</span>
<span class="sd">            Ordered dict, in order:</span>
<span class="sd">              - &#39;__TRIGGER&#39;, if argument **include_trigger** is True</span>
<span class="sd">              - &#39;__SAMPLE_INDEX&#39;, if argument **include_sample_info** is True</span>
<span class="sd">              - &#39;__WINDOW_INDEX&#39;, if argument **include_sample_info** is True</span>
<span class="sd">              - &#39;__WINDOW_SAMPLE_INDEX&#39;, if argument **include_sample_info** is True</span>
<span class="sd">              - &#39;__GAP&#39;, if argument **include_gap** is True</span>
<span class="sd">              - probe values in order of argument **probe_names**.</span>

<span class="sd">            Dict key: probe name. Dict value is list of int values, for a probe.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_waveform_data_values</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">probe_names</span><span class="p">,</span>
            <span class="n">start_window_idx</span><span class="p">,</span>
            <span class="n">window_count</span><span class="p">,</span>
            <span class="n">start_sample_idx</span><span class="p">,</span>
            <span class="n">sample_count</span><span class="p">,</span>
            <span class="n">include_trigger</span><span class="p">,</span>
            <span class="n">include_sample_info</span><span class="p">,</span>
            <span class="n">include_gap</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ILAWaveform.get_probe_data"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.get_probe_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_probe_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">probe_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get waveform data as a list of int values for one probe.</span>
<span class="sd">        By default, all samples for the probe are returned,</span>
<span class="sd">        It is possible to select window range and sample range.</span>

<span class="sd">        Args:</span>
<span class="sd">            probe_name (str): probe name.</span>
<span class="sd">            start_window_idx (int): Starting window index. Default is first window.</span>
<span class="sd">            window_count (Optional[int]): Number of windows to export. Default is all windows.</span>
<span class="sd">            start_sample_idx (int): Starting sample within window. Default is first sample.</span>
<span class="sd">            sample_count (Optional[int]): Number of samples per window. Default is all samples.</span>

<span class="sd">        Returns (List[int]):</span>
<span class="sd">            List probe values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_dict</span> <span class="o">=</span> <span class="n">get_waveform_data_values</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="p">[</span><span class="n">probe_name</span><span class="p">],</span>
            <span class="n">start_window_idx</span><span class="p">,</span>
            <span class="n">window_count</span><span class="p">,</span>
            <span class="n">start_sample_idx</span><span class="p">,</span>
            <span class="n">sample_count</span><span class="p">,</span>
            <span class="n">include_trigger</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">include_sample_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">include_gap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">res_dict</span><span class="p">[</span><span class="n">probe_name</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;data&quot;</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">pformat</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">data_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">json_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
            <span class="s2">&quot;sample_count&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_count</span><span class="p">,</span>
            <span class="s2">&quot;trigger_position&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">,</span>
            <span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span>
            <span class="s2">&quot;probes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">asdict</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="s2">&quot;data size&quot;</span><span class="p">:</span> <span class="nb">hex</span><span class="p">(</span><span class="n">data_size</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">json_dict</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Enum2StrEncoder</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<span class="k">def</span> <span class="nf">tcf_get_waveform_data</span><span class="p">(</span><span class="n">tcf_node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{}:</span>
    <span class="n">tcf_props</span> <span class="o">=</span> <span class="n">tcf_node</span><span class="o">.</span><span class="n">get_property_group</span><span class="p">([</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
    <span class="n">props</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_width&quot;</span><span class="p">],</span>
        <span class="s2">&quot;sample_count&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_sample_count&quot;</span><span class="p">],</span>
        <span class="s2">&quot;trigger_position&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_trigger_position&quot;</span><span class="p">],</span>
        <span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_window_size&quot;</span><span class="p">],</span>
        <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_data&quot;</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">props</span>


<span class="k">class</span> <span class="nc">WaveformWriter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TextIOBase</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handle</span> <span class="o">=</span> <span class="n">file_handle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probes</span> <span class="o">=</span> <span class="n">probes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probe_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probe_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_probe_names</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probe_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TextIOBase</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handle</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">make_values_unknown</span><span class="p">(</span><span class="n">in_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">unknown_ch</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">unknown_ch</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">in_values</span><span class="p">]</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">make_probe_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probes</span><span class="p">]</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">write_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_position</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">sample_in_window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">probe_binary_reversed_values</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">is_last_sample</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            sample_position (int):</span>
<span class="sd">            window_index (int):</span>
<span class="sd">            sample_in_window_index (int):</span>
<span class="sd">            is_trigger (bool):</span>
<span class="sd">            probe_binary_reversed_values ([str]): binary string values each start lsb at position zero.</span>
<span class="sd">            is_last_sample(bool): Last sample in waveform.</span>
<span class="sd">            is_gap (bool): True ig no data available for the sample.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">WaveformWriterCSV</span><span class="p">(</span><span class="n">WaveformWriter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">:</span> <span class="n">TextIOBase</span><span class="p">,</span> <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">],</span> <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">WaveformWriter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">,</span> <span class="n">probes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span> <span class="o">=</span> <span class="n">include_gap</span>

    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Sample in Buffer,Sample in Window,TRIGGER,&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;GAP,&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_probe_names</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Radix - UNSIGNED,UNSIGNED,UNSIGNED,&quot;</span><span class="p">)</span>
        <span class="c1"># Currently, HEX is the only supported radix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;HEX&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_count</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_probe_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">bus_range_str</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">write_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_position</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">sample_in_window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">probe_binary_reversed_values</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">is_last_sample</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hex_values</span> <span class="o">=</span> <span class="n">bin_reversed_to_hex_values</span><span class="p">(</span><span class="n">probe_binary_reversed_values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_gap</span><span class="p">:</span>
            <span class="n">hex_values</span> <span class="o">=</span> <span class="n">WaveformWriter</span><span class="o">.</span><span class="n">make_values_unknown</span><span class="p">(</span><span class="n">hex_values</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">hex_values_str</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hex_values</span><span class="p">)</span>
        <span class="n">trig_mark</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">is_trigger</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span><span class="p">:</span>
            <span class="n">gap_value</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">is_gap</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sample_position</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">sample_in_window_index</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">trig_mark</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">gap_value</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">hex_values_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sample_position</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">sample_in_window_index</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">trig_mark</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">hex_values_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">WaveformWriterToDict</span><span class="p">(</span><span class="n">WaveformWriter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">],</span>
        <span class="n">include_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">include_sample_info</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">WaveformWriter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">probes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_trigger</span> <span class="o">=</span> <span class="n">include_trigger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_sample_info</span> <span class="o">=</span> <span class="n">include_sample_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span> <span class="o">=</span> <span class="n">include_gap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result</span>

    <span class="k">def</span> <span class="nf">write_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_position</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">sample_in_window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">probe_binary_reversed_values</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">is_last_sample</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_trigger</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__TRIGGER&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_trigger</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_sample_info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__SAMPLE_INDEX&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_position</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__WINDOW_INDEX&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">window_index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__WINDOW_SAMPLE_INDEX&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_in_window_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__GAP&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_gap</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">int_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">r_val</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">r_val</span> <span class="ow">in</span> <span class="n">probe_binary_reversed_values</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">probe_name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_probe_names</span><span class="p">,</span> <span class="n">int_values</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="n">probe_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">WaveformWriterVCD</span><span class="p">(</span><span class="n">WaveformWriter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Value Change Dump format. See Wikipedia and IEEE Std 1364-2001.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">:</span> <span class="n">TextIOBase</span><span class="p">,</span> <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">],</span> <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">WaveformWriter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">,</span> <span class="n">probes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trigger_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gap_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span> <span class="o">=</span> <span class="n">include_gap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_trigger</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev_window_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_gap</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_vars</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Supports up to 94 + 94*94 + 94*94*94 = 839,514 probes (or variables).&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="nb">chr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">yy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="nb">chr</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xxx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">yyy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">zzz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="nb">chr</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">yyy</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">zzz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_variable_definitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">generate_vars</span> <span class="o">=</span> <span class="n">WaveformWriterVCD</span><span class="o">.</span><span class="n">_generate_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trigger_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gap_var</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">islice</span><span class="p">(</span>
            <span class="n">generate_vars</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_probe_count</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">width</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">probe_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_probe_widths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_names</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;$var reg </span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">probe_name</span><span class="si">}</span><span class="s2"> $end</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;$var reg 1 </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_trigger_var</span><span class="si">}</span><span class="s2"> _TRIGGER $end</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;$var reg 1 </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_var</span><span class="si">}</span><span class="s2"> _WINDOW $end</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;$var reg 1 </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_gap_var</span><span class="si">}</span><span class="s2"> _GAP $end</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_probe_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">bus_range_str</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">now</span> <span class="o">=</span> <span class="s2">&quot;{:%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="c1"># adjust for trigger position</span>
        <span class="n">hdr_1</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$date</span><span class="se">\n</span><span class="s2">        </span><span class="si">{</span><span class="n">now</span><span class="si">}</span><span class="se">\n</span><span class="s2">$end</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="n">hdr_2</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;$version</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;        ChipScoPy Version </span><span class="si">{</span><span class="n">chipscopy</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;$end</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;$timescale</span><span class="se">\n</span><span class="s2">        1ps</span><span class="se">\n</span><span class="s2">$end</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;$scope module dut $end</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">hdr_3</span> <span class="o">=</span> <span class="s2">&quot;$upscope $end</span><span class="se">\n</span><span class="s2">$enddefinitions $end</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">hdr_1</span> <span class="o">+</span> <span class="n">hdr_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_variable_definitions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">hdr_3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_position</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_index</span><span class="p">,</span>
        <span class="n">sample_in_window_index</span><span class="p">,</span>
        <span class="n">is_trigger</span><span class="p">,</span>
        <span class="n">probe_binary_reversed_values</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">is_last_sample</span><span class="p">,</span>
        <span class="n">is_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">time_written</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">write_value</span><span class="p">(</span><span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reversed_value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">nonlocal</span> <span class="n">time_written</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">time_written</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="n">sample_position</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">time_written</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reversed_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">reversed_value</span><span class="si">}{</span><span class="n">var</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="c1"># Remove leading zeroes</span>
            <span class="k">if</span> <span class="n">is_gap</span> <span class="ow">and</span> <span class="n">reversed_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">reversed_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Remove leading zeroes</span>
                <span class="n">msb_idx</span> <span class="o">=</span> <span class="n">reversed_value</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">msb_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msb_idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">reversed_value</span><span class="p">[</span><span class="n">msb_idx</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;b</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Write time, for last sample, even if no changes.</span>
        <span class="k">if</span> <span class="n">is_last_sample</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="n">sample_position</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">time_written</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Trigger value</span>
        <span class="k">if</span> <span class="n">is_trigger</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_trigger</span><span class="p">:</span>
            <span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trigger_var</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">is_trigger</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_trigger</span> <span class="o">=</span> <span class="n">is_trigger</span>

        <span class="c1"># Window marker.</span>
        <span class="k">if</span> <span class="n">window_index</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev_window_index</span><span class="p">:</span>
            <span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_var</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">window_index</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prev_window_index</span> <span class="o">=</span> <span class="n">window_index</span>

        <span class="c1"># gap value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span> <span class="ow">and</span> <span class="n">is_gap</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_gap</span><span class="p">:</span>
            <span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gap_var</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">is_gap</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_gap</span> <span class="o">=</span> <span class="n">is_gap</span>

        <span class="c1"># Regular values</span>
        <span class="k">if</span> <span class="n">is_gap</span><span class="p">:</span>
            <span class="n">probe_binary_reversed_values</span> <span class="o">=</span> <span class="n">WaveformWriter</span><span class="o">.</span><span class="n">make_values_unknown</span><span class="p">(</span>
                <span class="n">probe_binary_reversed_values</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">new_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">probe_binary_reversed_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_val</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
            <span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">new_val</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">export_waveform_to_stream</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">ILAWaveform</span><span class="p">,</span>
    <span class="n">export_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">stream_handle</span><span class="p">:</span> <span class="n">TextIOBase</span><span class="p">,</span>
    <span class="n">probe_names</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Arguments documented in calling API function&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">probe_names</span><span class="p">:</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[</span><span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">p_name</span> <span class="ow">in</span> <span class="n">probe_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">probes</span><span class="p">):</span>
            <span class="n">bad_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">probe_names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;export_waveform() called with non-existent probe_name:</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">bad_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;CSV&quot;</span><span class="p">:</span>
        <span class="n">waveform_writer</span> <span class="o">=</span> <span class="n">WaveformWriterCSV</span><span class="p">(</span><span class="n">stream_handle</span><span class="p">,</span> <span class="n">probes</span><span class="p">,</span> <span class="n">include_gap</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;VCD&quot;</span><span class="p">:</span>
        <span class="n">waveform_writer</span> <span class="o">=</span> <span class="n">WaveformWriterVCD</span><span class="p">(</span><span class="n">stream_handle</span><span class="p">,</span> <span class="n">probes</span><span class="p">,</span> <span class="n">include_gap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;ILAWaveform.export_waveform() called with non-supported format &quot;</span><span class="si">{</span><span class="n">export_format</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
        <span class="p">)</span>

    <span class="n">_export_waveform</span><span class="p">(</span>
        <span class="n">waveform</span><span class="p">,</span>
        <span class="n">waveform_writer</span><span class="p">,</span>
        <span class="n">probes</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">,</span>
        <span class="s2">&quot;export_waveform()&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">get_waveform_data_values</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">ILAWaveform</span><span class="p">,</span>
    <span class="n">probe_names</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">include_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">include_sample_info</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Arguments documented in calling API function&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">probe_names</span><span class="p">:</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[</span><span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">p_name</span> <span class="ow">in</span> <span class="n">probe_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">probes</span><span class="p">):</span>
            <span class="n">bad_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">probe_names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;ILAWaveform.get_data() called with non-existent probe name(s):</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">bad_names</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="n">waveform_writer</span> <span class="o">=</span> <span class="n">WaveformWriterToDict</span><span class="p">(</span>
        <span class="n">probes</span><span class="p">,</span> <span class="n">include_trigger</span><span class="p">,</span> <span class="n">include_sample_info</span><span class="p">,</span> <span class="n">include_gap</span>
    <span class="p">)</span>
    <span class="n">_export_waveform</span><span class="p">(</span>
        <span class="n">waveform</span><span class="p">,</span>
        <span class="n">waveform_writer</span><span class="p">,</span>
        <span class="n">probes</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">,</span>
        <span class="s2">&quot;ILAWaveform.get_data()&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">waveform_writer</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_export_waveform</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">ILAWaveform</span><span class="p">,</span>
    <span class="n">writer</span><span class="p">:</span> <span class="n">WaveformWriter</span><span class="p">,</span>
    <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">],</span>
    <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">calling_function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">get_sample_binary_values</span><span class="p">(</span><span class="n">sample_data</span><span class="p">:</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">sample_int_value</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s2">&quot;little&quot;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">reversed_bin_value</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sample_int_value</span><span class="si">:</span><span class="s2">0</span><span class="si">{</span><span class="n">waveform</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s2">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="n">probes</span><span class="p">:</span>
            <span class="c1"># Each probe value can be made up of multiple bit range slices.</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="n">reversed_bin_value</span><span class="p">[</span><span class="n">br</span><span class="o">.</span><span class="n">index</span> <span class="p">:</span> <span class="n">br</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">br</span><span class="o">.</span><span class="n">length</span><span class="p">]</span> <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">probe</span><span class="o">.</span><span class="n">map_range</span><span class="p">]</span>
            <span class="n">p_val</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">is_gap</span><span class="p">(</span><span class="n">sample_high_byte</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">gap_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gap_index</span> <span class="ow">and</span> <span class="n">sample_high_byte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">gap_index</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">window_count</span><span class="p">:</span>
        <span class="n">window_count</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">get_window_count</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sample_count</span><span class="p">:</span>
        <span class="n">sample_count</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">window_size</span>

    <span class="n">w_size</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">window_size</span>
    <span class="n">max_window_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span> <span class="o">+</span> <span class="n">w_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">w_size</span>
    <span class="k">if</span> <span class="n">start_window_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">start_window_idx</span> <span class="o">&gt;=</span> <span class="n">max_window_count</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">calling_function</span><span class="si">}</span><span class="s1"> function argument start_window=&quot;</span><span class="si">{</span><span class="n">start_window_idx</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;must be in the range [0-</span><span class="si">{</span><span class="n">max_window_count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">start_sample_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">start_sample_idx</span> <span class="o">&gt;=</span> <span class="n">w_size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">calling_function</span><span class="si">}</span><span class="s1"> function argument &quot;start_sample=&quot;</span><span class="si">{</span><span class="n">start_sample_idx</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;must be in the range [0-</span><span class="si">{</span><span class="n">w_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_count</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sample_count</span> <span class="o">&gt;</span> <span class="n">w_size</span> <span class="o">-</span> <span class="n">start_sample_idx</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">calling_function</span><span class="si">}</span><span class="s1"> function argument &quot;sample_count=&quot;</span><span class="si">{</span><span class="n">sample_count</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;must be in the range [1-</span><span class="si">{</span><span class="n">w_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_sample_idx</span><span class="si">}</span><span class="s2">], &quot;</span>
            <span class="sa">f</span><span class="s1">&#39;since start_sample_idx=&quot;</span><span class="si">{</span><span class="n">start_sample_idx</span><span class="si">}</span><span class="s1">&quot;.&#39;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">window_count</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">window_count</span> <span class="o">&gt;</span> <span class="n">max_window_count</span> <span class="o">-</span> <span class="n">start_window_idx</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">calling_function</span><span class="si">}</span><span class="s1"> function argument &quot;window_count=&quot;</span><span class="si">{</span><span class="n">window_count</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;must be in the range [1-</span><span class="si">{</span><span class="n">max_window_count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_window_idx</span><span class="si">}</span><span class="s2">], &quot;</span>
            <span class="sa">f</span><span class="s1">&#39;since start_window_idx=&quot;</span><span class="si">{</span><span class="n">start_window_idx</span><span class="si">}</span><span class="s1">&quot;.&#39;</span>
        <span class="p">)</span>

    <span class="n">sample_byte_count</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">bytes_per_sample</span><span class="p">()</span>
    <span class="n">raw_samples</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">sample_is_gap</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">window_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_window_idx</span><span class="p">,</span> <span class="n">start_window_idx</span> <span class="o">+</span> <span class="n">window_count</span><span class="p">):</span>
        <span class="n">window_start_sample_idx</span> <span class="o">=</span> <span class="n">window_idx</span> <span class="o">*</span> <span class="n">w_size</span>
        <span class="n">trigger_sample_idx</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">[</span><span class="n">window_idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
            <span class="n">window_start_sample_idx</span> <span class="o">+</span> <span class="n">start_sample_idx</span><span class="p">,</span>
            <span class="n">window_start_sample_idx</span> <span class="o">+</span> <span class="n">start_sample_idx</span> <span class="o">+</span> <span class="n">sample_count</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">sample_idx</span> <span class="o">&gt;=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span><span class="p">:</span>
                <span class="c1"># last window is not full.</span>
                <span class="k">break</span>
            <span class="n">raw_sample_idx</span> <span class="o">=</span> <span class="n">sample_idx</span> <span class="o">*</span> <span class="n">sample_byte_count</span>
            <span class="n">raw_sample_idx_end</span> <span class="o">=</span> <span class="n">raw_sample_idx</span> <span class="o">+</span> <span class="n">sample_byte_count</span>
            <span class="n">sample_idx_in_window</span> <span class="o">=</span> <span class="n">sample_idx</span> <span class="o">-</span> <span class="n">window_start_sample_idx</span>
            <span class="n">bin_values</span> <span class="o">=</span> <span class="n">get_sample_binary_values</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">[</span><span class="n">raw_sample_idx</span><span class="p">:</span><span class="n">raw_sample_idx_end</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">gap_index</span><span class="p">:</span>
                <span class="n">sample_is_gap</span> <span class="o">=</span> <span class="n">is_gap</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">[</span><span class="n">raw_sample_idx_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">waveform</span><span class="o">.</span><span class="n">gap_index</span><span class="p">)</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write_sample</span><span class="p">(</span>
                <span class="n">sample_idx</span><span class="p">,</span>
                <span class="n">window_idx</span><span class="p">,</span>
                <span class="n">sample_idx_in_window</span><span class="p">,</span>
                <span class="n">sample_idx_in_window</span> <span class="o">==</span> <span class="n">trigger_sample_idx</span><span class="p">,</span>
                <span class="n">bin_values</span><span class="p">,</span>
                <span class="n">sample_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span><span class="p">,</span>
                <span class="n">sample_is_gap</span><span class="p">,</span>
            <span class="p">)</span>


<span class="n">WAVEFORM_ARCHIVE_VERSION</span> <span class="o">=</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">Waveform2StrEncoder</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">JSONEncoder</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">encode_map_range</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># Convert ILABitRange tuple to a dict, e.g. [{&quot;index&quot;: 0, &quot;length&quot;: 2}]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">elem</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ILABitRange</span><span class="p">)</span> <span class="k">else</span> <span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ILAWaveformProbe</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">Waveform2StrEncoder</span><span class="o">.</span><span class="n">encode_map_range</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">asdict</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ILABitRange</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ILAProbeRadix</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">EnumMeta</span><span class="p">):</span>
            <span class="c1"># Encode as 2-item list: [&lt;name&gt;, &lt;dict of enum value items&gt;]</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">{</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="p">)}</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">items</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">JSONEncoder</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">export_compressed_waveform</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">ILAWaveform</span><span class="p">,</span>
    <span class="n">filepath_or_buffer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">],</span>
    <span class="n">compression</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">compresslevel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">waveform_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;gap_index&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">gap_index</span><span class="p">,</span>
        <span class="s2">&quot;probes&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="p">,</span>
        <span class="s2">&quot;sample_count&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span><span class="p">,</span>
        <span class="s2">&quot;trigger_position&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">,</span>
        <span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span>
        <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">json_str</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">waveform_dict</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Waveform2StrEncoder</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span>
        <span class="n">filepath_or_buffer</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="n">allowZip64</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
        <span class="n">compresslevel</span><span class="o">=</span><span class="n">compresslevel</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">zf</span><span class="p">:</span>
        <span class="n">zf</span><span class="o">.</span><span class="n">writestr</span><span class="p">(</span><span class="s2">&quot;waveform.cfg&quot;</span><span class="p">,</span> <span class="n">json_str</span><span class="p">)</span>
        <span class="n">zf</span><span class="o">.</span><span class="n">writestr</span><span class="p">(</span><span class="s2">&quot;waveform.data&quot;</span><span class="p">,</span> <span class="n">waveform</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">decode_waveform_from_json</span><span class="p">(</span><span class="n">json_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">in_data</span><span class="p">:</span> <span class="nb">bytearray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ILAWaveform</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">decode_map_range</span><span class="p">(</span><span class="n">in_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ILABitRange</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">ILABitRange</span><span class="p">(</span><span class="o">**</span><span class="n">dd</span><span class="p">)</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">in_range</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">decode_probe</span><span class="p">(</span><span class="n">probe_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">in_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ILAWaveformProbe</span><span class="p">:</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;map_range&quot;</span><span class="p">:</span>
                    <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">decode_map_range</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;display_radix&quot;</span><span class="p">:</span>
                    <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ILAProbeRadix</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;enum_def&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error reading ILA waveform probe &quot;</span><span class="si">{</span><span class="n">probe_name</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">ex</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">ILAWaveformProbe</span><span class="p">(</span><span class="o">**</span><span class="n">pd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">decode_probes</span><span class="p">(</span><span class="n">in_probes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ILAWaveformProbe</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">decode_probe</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">probe_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">probe_dict</span> <span class="ow">in</span> <span class="n">in_probes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># Decode waveform json string.</span>
    <span class="n">json_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">json_str</span><span class="p">))</span>
    <span class="n">wd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">wd</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_data</span>
    <span class="n">wd</span><span class="p">[</span><span class="s2">&quot;probes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decode_probes</span><span class="p">(</span><span class="n">json_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;probes&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">()))</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;probes&quot;</span><span class="p">]:</span>
            <span class="c1"># data and probes, handled above.</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;version&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">WAVEFORM_ARCHIVE_VERSION</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;waveform archive version &quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&quot; is not supported.&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;Only versions &quot;&lt;=</span><span class="si">{</span><span class="n">WAVEFORM_ARCHIVE_VERSION</span><span class="si">}</span><span class="s1">&quot; are supported.&#39;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">ILAWaveform</span><span class="p">(</span><span class="o">**</span><span class="n">wd</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">import_compressed_waveform</span><span class="p">(</span><span class="n">filepath_or_buffer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ILAWaveform</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">filepath_or_buffer</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">zf</span><span class="p">:</span>
        <span class="n">json_str</span> <span class="o">=</span> <span class="n">zf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;waveform.cfg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">zf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;waveform.data&quot;</span><span class="p">))</span>

    <span class="n">waveform</span> <span class="o">=</span> <span class="n">decode_waveform_from_json</span><span class="p">(</span><span class="n">json_str</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">waveform</span>
</pre></div>

           </div>
          </div>
          
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2024, Advanced Micro Devices, Inc.
      <span class="lastupdated">Last updated on June 07, 2024.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>