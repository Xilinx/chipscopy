<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-C0002">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5RHQV7');</script>
<!-- End Google Tag Manager -->
  <title>chipscopy.api.ila.ila_waveform &mdash; ChipScoPy XXXXXXX documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5RHQV7" height="0" width="0" style="display:none;visibility:hidden" class="optanon-category-C0002"></iframe></noscript>
<!-- End Google Tag Manager --> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> ChipScoPy
          </a>
              <div class="version">
                2025.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../overview.html">ChipScoPy Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chipscopy_installation.html">ChipScoPy Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ChipScoPy Debug Core API Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ddr.html">DDR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ibert.html">IBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ila.html">ILA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory.html">Memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../noc.html">NocPerfmon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pcie.html">PCIe</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sysmon.html">SysMon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../vio.html">VIO</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Misc Classes &amp; Utility Functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../containers.html">Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../device.html">Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../report.html">Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../session.html">Session</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ChipScoPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
          <li><a href="../../api.html">chipscopy.api</a> &raquo;</li>
      <li>chipscopy.api.ila.ila_waveform</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for chipscopy.api.ila.ila_waveform</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2021-2022, Xilinx, Inc.</span>
<span class="c1"># Copyright (C) 2022-2025, Advanced Micro Devices, Inc.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">zipfile</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">chipscopy.api.ila.ila_protocol_processing</span> <span class="kn">import</span> <span class="n">Rule</span><span class="p">,</span> <span class="n">TransactionSpec</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">asdict</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">TextIOBase</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">,</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pformat</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">zipfile</span> <span class="kn">import</span> <span class="n">ZipFile</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">chipscopy.api.ila</span> <span class="kn">import</span> <span class="n">ILABitRange</span><span class="p">,</span> <span class="n">ILAProbeRadix</span>
<span class="kn">import</span> <span class="nn">chipscopy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">chipscopy.shared.ila_util</span> <span class="kn">import</span> <span class="n">bin_reversed_to_hex_values</span>
<span class="kn">from</span> <span class="nn">chipscopy.utils</span> <span class="kn">import</span> <span class="n">Enum2StrEncoder</span>


<div class="viewcode-block" id="ILAWaveformProbe"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveformProbe">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ILAWaveformProbe</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Probe location in a data sample.&quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of probe.&quot;&quot;&quot;</span>
    <span class="nb">map</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location string&quot;&quot;&quot;</span>
    <span class="n">map_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ILABitRange</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;List of bit ranges. See :class:`~chipscopy.api.ila.ILABitRange`&quot;&quot;&quot;</span>
    <span class="n">is_bus</span><span class="p">:</span> <span class="nb">bool</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;True for bus probes&quot;&quot;&quot;</span>
    <span class="n">bus_left_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Bus left index. E.g. 5 in probe ``counter[5:0]``&quot;&quot;&quot;</span>
    <span class="n">bus_right_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bus right index. E.g. 0 in probe ``counter[5:0]``&quot;&quot;&quot;</span>
    <span class="n">display_radix</span><span class="p">:</span> <span class="n">ILAProbeRadix</span> <span class="o">=</span> <span class="n">ILAProbeRadix</span><span class="o">.</span><span class="n">HEX</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Display radix, when exporting waveform data. Default is ILAProbeRadix.HEX&quot;&quot;&quot;</span>
    <span class="n">enum_def</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">enum</span><span class="o">.</span><span class="n">EnumMeta</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enum class defining {name:int} enum values, for this probe.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mr</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">mr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_range</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bus_range_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bus</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bus_left_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">bus_right_index</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bus_left_index</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bus_left_index</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bus_right_index</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">return</span> <span class="n">res</span></div>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ProbeGroup</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a group of related probes in the waveform.&quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">probes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">is_expanded</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># For UI state</span>
    <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># For visual grouping</span>
    <span class="n">rules</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Rule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">rule_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">any</span><span class="p">]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># Store results</span>
    <span class="n">enum_mappings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">channel_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">add_probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probe_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a probe to this group.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">probe_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">probe_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probe_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a probe from this group.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">probe_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">probe_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">:</span> <span class="s2">&quot;Rule&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a rule to this probe group.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_enum_mappings_to_text_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">enum_mappings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write enum mappings to a simple text file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Output filename</span>
<span class="sd">            enum_mappings: Dictionary of signal names to their enum mappings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">enum_mappings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># Sort by value</span>
        <span class="n">sorted_mapping</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">enum_mappings</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Get bit width</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">enum_mappings</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">enum_mappings</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">bit_width</span> <span class="o">=</span> <span class="n">max_value</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="k">if</span> <span class="n">max_value</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">sorted_mapping</span><span class="p">:</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;0</span><span class="si">{</span><span class="n">bit_width</span><span class="si">}</span><span class="s2">b&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">display_label</span> <span class="o">=</span> <span class="s2">&quot;NOEVENTS&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">display_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">output_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">binary</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">display_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_lines</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Enum mappings written to </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calculate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="s2">&quot;ILAWaveform&quot;</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply rules specific to this probe group and create interval signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">refactor_rules</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">num_slots</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">refactor_rules</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">:</span>
            <span class="c1"># Create signal mapping only from probes in this group</span>
            <span class="n">signal_mapping</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">rule</span><span class="o">.</span><span class="n">signals</span><span class="p">:</span>
                <span class="c1"># Find matching probes within this group&#39;s probes</span>
                <span class="n">tsignal</span> <span class="o">=</span> <span class="n">signal</span>
                <span class="k">if</span> <span class="n">refactor_rules</span><span class="p">:</span>
                    <span class="n">tsignal</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;SLOT_</span><span class="si">{</span><span class="n">slot</span><span class="si">}</span><span class="s2">_AXI/</span><span class="si">{</span><span class="n">signal</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">matching_probes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">probe_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">probe_name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">tsignal</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                        <span class="n">matching_probes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">probe_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_probes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">signal_mapping</span><span class="p">[</span><span class="n">signal</span><span class="p">]</span> <span class="o">=</span> <span class="n">matching_probes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_probes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Warning: Multiple probes in group &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; match &#39;</span><span class="si">{</span><span class="n">signal</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">matching_probes</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">signal_mapping</span><span class="p">[</span><span class="n">signal</span><span class="p">]</span> <span class="o">=</span> <span class="n">matching_probes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: No probe in group &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; found for signal &#39;</span><span class="si">{</span><span class="n">signal</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="c1"># Skip if we couldn&#39;t find all required signals</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal_mapping</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">signals</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Get signal data</span>
            <span class="n">signal_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">simple_name</span><span class="p">:</span> <span class="n">all_data</span><span class="p">[</span><span class="n">full_name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">simple_name</span><span class="p">,</span> <span class="n">full_name</span> <span class="ow">in</span> <span class="n">signal_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="c1"># Create context with helper methods</span>
            <span class="k">class</span> <span class="nc">Context</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">rising_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">signal_data</span><span class="p">[</span><span class="n">signal</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

                <span class="k">def</span> <span class="nf">both_asserted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig1</span><span class="p">,</span> <span class="n">sig2</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">signal_data</span><span class="p">[</span><span class="n">sig1</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">signal_data</span><span class="p">[</span><span class="n">sig2</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

                <span class="k">def</span> <span class="nf">signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">signal_data</span><span class="p">[</span><span class="n">signal</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>

            <span class="c1"># Build hits list</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">applies</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Error applying rule &#39;</span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; at index </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> in group &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Find intervals</span>
            <span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">fire</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hits</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">fire</span> <span class="ow">and</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">fire</span> <span class="ow">and</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># Create manual interval signal for this rule</span>
            <span class="c1"># Store results instead of creating signals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rule_results</span><span class="p">[</span><span class="n">rule</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;hits&quot;</span><span class="p">:</span> <span class="n">hits</span><span class="p">,</span>  <span class="c1"># Boolean array of where rule fires</span>
                <span class="s2">&quot;intervals&quot;</span><span class="p">:</span> <span class="n">intervals</span><span class="p">,</span>  <span class="c1"># List of (start, end) tuples</span>
                <span class="s2">&quot;signal_mapping&quot;</span><span class="p">:</span> <span class="n">signal_mapping</span><span class="p">,</span>  <span class="c1"># Which signals were used</span>
                <span class="s2">&quot;hit_count&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">hits</span><span class="p">),</span>  <span class="c1"># Total number of hits</span>
                <span class="s2">&quot;hit_indices&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span> <span class="k">if</span> <span class="n">h</span><span class="p">],</span>  <span class="c1"># Indices where rule fired</span>
            <span class="p">}</span>

    <span class="k">def</span> <span class="nf">get_rule_hits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the hit array for a specific rule.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rule_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_results</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_results</span><span class="p">[</span><span class="n">rule_name</span><span class="p">][</span><span class="s2">&quot;hits&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">get_rule_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Tuple&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the intervals where a specific rule fired.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rule_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_results</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_results</span><span class="p">[</span><span class="n">rule_name</span><span class="p">][</span><span class="s2">&quot;intervals&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">create_interval_signals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="s2">&quot;ILAWaveform&quot;</span><span class="p">,</span> <span class="n">rule_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a single enum signal for this group combining all rules.&quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a single combined enum signal for all rules in this probe group.&quot;&quot;&quot;</span>
        <span class="c1"># Get rule names from rule_results if not provided</span>
        <span class="k">if</span> <span class="n">rule_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rule_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_results</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">rules_to_process</span> <span class="o">=</span> <span class="n">rule_names</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">rules_to_process</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Build enum mapping: each rule gets a unique bit</span>
        <span class="c1"># Example: rule1=0b01, rule2=0b10, both=0b11, neither=0b00</span>
        <span class="n">enum_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>  <span class="c1"># Empty string for no rules active</span>
        <span class="n">rule_bit_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Assign each rule a unique bit position</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rule_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rules_to_process</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rule_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_results</span><span class="p">:</span>
                <span class="n">bit_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>  <span class="c1"># 2^i</span>
                <span class="n">rule_bit_map</span><span class="p">[</span><span class="n">rule_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">bit_value</span>
                <span class="n">enum_mapping</span><span class="p">[</span><span class="n">rule_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">bit_value</span>

        <span class="c1"># Generate all possible combinations</span>
        <span class="n">num_rules</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rule_bit_map</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">num_rules</span><span class="p">):</span>  <span class="c1"># Skip 0 (empty)</span>
            <span class="c1"># Build label for this combination</span>
            <span class="n">active_rules</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rule_name</span><span class="p">,</span> <span class="n">bit_value</span> <span class="ow">in</span> <span class="n">rule_bit_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">combo</span> <span class="o">&amp;</span> <span class="n">bit_value</span><span class="p">:</span>
                    <span class="n">active_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_rules</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Multiple rules active</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">active_rules</span><span class="p">)</span>
                <span class="n">enum_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">combo</span>

        <span class="c1"># Create values array for each sample</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span>
        <span class="c1"># Move this to gtkw in export waveform</span>

        <span class="c1"># For each sample, determine which rules are active</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span><span class="p">):</span>
            <span class="n">active_value</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">active_rules</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">rule_name</span> <span class="ow">in</span> <span class="n">rules_to_process</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rule_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_results</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check if this rule fires at this index</span>
                <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_results</span><span class="p">[</span><span class="n">rule_name</span><span class="p">][</span><span class="s2">&quot;hits&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hits</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="n">active_value</span> <span class="o">|=</span> <span class="n">rule_bit_map</span><span class="p">[</span><span class="n">rule_name</span><span class="p">]</span>
                    <span class="n">active_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule_name</span><span class="p">)</span>

            <span class="c1"># Set the appropriate label</span>
            <span class="k">if</span> <span class="n">active_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_rules</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">active_rules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">active_rules</span><span class="p">)</span>

        <span class="c1"># Create the combined signal</span>
        <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">num_slots</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">signal_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;SLOT_</span><span class="si">{</span><span class="n">slot</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_Events&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signal_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_Events&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_name</span> <span class="o">=</span> <span class="n">signal_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enum_mappings</span> <span class="o">=</span> <span class="n">enum_mapping</span>
        <span class="n">waveform</span><span class="o">.</span><span class="n">append_manual_enum_signal</span><span class="p">(</span><span class="n">signal_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">enum_mapping</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="p">)</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Transaction</span><span class="p">:</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># &quot;read&quot; | &quot;write&quot;</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>  <span class="c1"># ARID/AWID (0 if not present)</span>
    <span class="n">addr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>  <span class="c1"># ARADDR/AWADDR (int if available)</span>
    <span class="n">start_idx</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">probes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># captured open fields</span>
    <span class="n">slot</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">end_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">resp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">channel_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># e.g. &quot;AXI_ID_2_Write</span>
    <span class="n">enum</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;ACTIVE&quot;</span><span class="p">})</span>
    <span class="n">meta</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">)</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">TopTransactionAssembler</span><span class="p">:</span>
    <span class="n">specs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;TransactionSpec&quot;</span><span class="p">]</span>
    <span class="n">slot_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;AXI&quot;</span>

    <span class="c1"># per-slot assemblers and results</span>
    <span class="n">assemblers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;SimpleTransactionAssembler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">transactions_by_slot</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Transaction&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="s2">&quot;ILAWaveform&quot;</span><span class="p">):</span>
        <span class="c1"># Determine slots from waveform if not provided</span>
        <span class="n">waveform</span><span class="o">.</span><span class="n">transactionAssembler</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_slots</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="s2">&quot;num_slots&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slot_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_slots</span><span class="p">))</span>

        <span class="c1"># Create per-slot assemblers once</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemblers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot_indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assemblers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SimpleTransactionAssembler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">,</span> <span class="n">slot</span><span class="o">=</span><span class="n">s</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="s2">&quot;ILAWaveform&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Transaction&quot;</span><span class="p">]]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">waveform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transactions_by_slot</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">asm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemblers</span><span class="p">:</span>
            <span class="n">txns</span> <span class="o">=</span> <span class="n">asm</span><span class="o">.</span><span class="n">calculate_values</span><span class="p">(</span><span class="n">waveform</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transactions_by_slot</span><span class="p">[</span><span class="n">asm</span><span class="o">.</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">txns</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactions_by_slot</span>

    <span class="k">def</span> <span class="nf">append_lanes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="s2">&quot;ILAWaveform&quot;</span><span class="p">,</span> <span class="n">separate_by_kind</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># Append per-slot lanes to the waveform</span>
        <span class="k">for</span> <span class="n">asm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemblers</span><span class="p">:</span>
            <span class="c1"># Set a per-slot prefix to avoid name collisions between slots</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name_prefix</span><span class="si">}</span><span class="s2">_SLOT</span><span class="si">{</span><span class="n">asm</span><span class="o">.</span><span class="n">slot</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">asm</span><span class="o">.</span><span class="n">append_per_id_binary_lanes</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">name_prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_gtkw_translate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">vcd_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separate_by_kind</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write per-slot translate tables + .gtkw files, returns list of file paths.&quot;&quot;&quot;</span>
        <span class="n">written</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">asm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemblers</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name_prefix</span><span class="si">}</span><span class="s2">_SLOT</span><span class="si">{</span><span class="n">asm</span><span class="o">.</span><span class="n">slot</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">gtkw</span> <span class="o">=</span> <span class="n">asm</span><span class="o">.</span><span class="n">write_gtkw_with_translate</span><span class="p">(</span>
                <span class="n">out_dir</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span>
                <span class="n">name_prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">written</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gtkw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">written</span>

    <span class="k">def</span> <span class="nf">all_transactions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Transaction&quot;</span><span class="p">]:</span>
        <span class="c1"># Flatten across slots if needed</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transactions_by_slot</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">get_transactions_by_slot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Transaction&quot;</span><span class="p">]]:</span>
        <span class="c1"># Flatten across slots if needed</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactions_by_slot</span>


<span class="k">class</span> <span class="nc">SimpleTransactionAssembler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates each TransactionSpec over the waveform and pairs opens-&gt;closes</span>
<span class="sd">    using a per-ID FIFO. Ignores counters/overflows for now.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TransactionSpec</span><span class="p">],</span> <span class="n">slot</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">specs</span> <span class="o">=</span> <span class="n">specs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transactions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Transaction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">slot</span>

    <span class="k">def</span> <span class="nf">_bind_sigmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">],</span> <span class="n">names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="c1"># Case-insensitive exact-key binding: &quot;ARID&quot; -&gt; actual key in all_data</span>
        <span class="n">sigmap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="c1"># gather candidates</span>
            <span class="n">cands</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cands</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">sigmap</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">cands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sigmap</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_to_int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">append_per_id_binary_lanes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">waveform</span><span class="p">:</span> <span class="s2">&quot;ILAWaveform&quot;</span><span class="p">,</span>
        <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each ID, create a 0/1 lane indicating transaction activity over time.</span>
<span class="sd">        If separate_by_kind=True, create distinct lanes per (ID, kind).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span>
        <span class="n">base_name</span> <span class="o">=</span> <span class="n">name_prefix</span> <span class="ow">or</span> <span class="s2">&quot;AXI&quot;</span>

        <span class="c1"># Collect IDs (and kinds if requested)</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">end_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">id</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># Enum mapping for binary 0/1</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">cur_id</span><span class="p">,</span> <span class="n">cur_kind</span><span class="p">),</span> <span class="n">txns</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Sort by start time, then end time for stability</span>
            <span class="n">txns</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">end_idx</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">end_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">start_idx</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Greedy packing into non-overlapping lanes</span>
            <span class="n">lane_last_end</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># last end index for each lane</span>
            <span class="n">lanes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of lists of transactions per lane</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">txns</span><span class="p">:</span>
                <span class="n">placed</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">li</span><span class="p">,</span> <span class="n">last_end</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lane_last_end</span><span class="p">):</span>
                    <span class="c1"># Place in the first lane that doesn&#39;t overlap (strictly after last end)</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">start_idx</span> <span class="o">&gt;</span> <span class="n">last_end</span><span class="p">:</span>
                        <span class="n">lanes</span><span class="p">[</span><span class="n">li</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="n">lane_last_end</span><span class="p">[</span><span class="n">li</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">end_idx</span>
                        <span class="n">placed</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">placed</span><span class="p">:</span>
                    <span class="n">lanes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t</span><span class="p">])</span>
                    <span class="n">lane_last_end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">end_idx</span><span class="p">)</span>

            <span class="c1"># Emit one enum lane per lane index</span>
            <span class="k">for</span> <span class="n">li</span><span class="p">,</span> <span class="n">lane_txns</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lanes</span><span class="p">):</span>
                <span class="n">lane_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_name</span><span class="si">}</span><span class="s2">_ID</span><span class="si">{</span><span class="n">cur_id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cur_kind</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">li</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;-&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
                <span class="n">enum_map</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
                <span class="n">next_code</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lane_txns</span><span class="p">:</span>
                    <span class="n">addr_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;0x</span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">addr</span><span class="si">:</span><span class="s2">X</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">addr</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;N/A&quot;</span>
                    <span class="n">resp_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">resp</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">resp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;N/A&quot;</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">kind</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> ID=</span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> ADDR=</span><span class="si">{</span><span class="n">addr_str</span><span class="si">}</span><span class="s2"> RESP=</span><span class="si">{</span><span class="n">resp_str</span><span class="si">}</span><span class="s2">&quot;</span>

                    <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">enum_map</span><span class="p">:</span>
                        <span class="n">enum_map</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_code</span>
                        <span class="n">next_code</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># Optionally attach mapping and lane name back to the txn</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">enum</span> <span class="o">=</span> <span class="p">{</span><span class="n">code</span><span class="p">:</span> <span class="n">lab</span> <span class="k">for</span> <span class="n">lab</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">enum_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">channel_name</span> <span class="o">=</span> <span class="n">lane_name</span>

                    <span class="n">s</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">start_idx</span><span class="p">)</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">end_idx</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>

                <span class="n">waveform</span><span class="o">.</span><span class="n">append_manual_enum_signal</span><span class="p">(</span><span class="n">lane_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">enum_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calculate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="s2">&quot;ILAWaveform&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Transaction</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>

        <span class="c1"># if waveform.num_slots &gt;</span>
        <span class="c1">#</span>
        <span class="c1"># else:</span>
        <span class="n">pgs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">waveform</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">]</span> <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">num_slots</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">waveform</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Iterate through all groups in that slot</span>
        <span class="k">for</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">probe_group</span> <span class="ow">in</span> <span class="n">pgs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># process each probe_group</span>
            <span class="n">probes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">probe_group</span><span class="o">.</span><span class="n">probes</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">probes</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span>
        <span class="n">txns_all</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Transaction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">num_slots</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">rf</span><span class="s2">&quot;(?&lt;=/|_)</span><span class="si">{</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
                    <span class="n">ks</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ks</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ks</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">m</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">m</span>

        <span class="k">def</span> <span class="nf">make_ctx</span><span class="p">(</span><span class="n">sigmap</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
            <span class="k">class</span> <span class="nc">Ctx</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">rising_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sigmap</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">sigmap</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span>
                    <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

                <span class="k">def</span> <span class="nf">both_asserted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sigmap</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sigmap</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">sigmap</span><span class="p">[</span><span class="n">a</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="n">sigmap</span><span class="p">[</span><span class="n">b</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

                <span class="k">def</span> <span class="nf">signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">sigmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">Ctx</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">to_int</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
            <span class="n">open_cnt_name</span> <span class="o">=</span> <span class="s2">&quot;AR_CNT&quot;</span> <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">txn_type</span> <span class="o">==</span> <span class="s2">&quot;read&quot;</span> <span class="k">else</span> <span class="s2">&quot;AW_CNT&quot;</span>
            <span class="n">close_cnt_name</span> <span class="o">=</span> <span class="s2">&quot;R_CNT&quot;</span> <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">txn_type</span> <span class="o">==</span> <span class="s2">&quot;read&quot;</span> <span class="k">else</span> <span class="s2">&quot;B_CNT&quot;</span>
            <span class="n">overflowed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># length</span>
            <span class="n">next_ticket</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="n">pending_by_id_ticket</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Transaction</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

            <span class="c1"># Build signal maps for open/close including fields youll read</span>

            <span class="n">open_need</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="o">*</span><span class="n">spec</span><span class="o">.</span><span class="n">open_rule</span><span class="o">.</span><span class="n">signals</span><span class="p">,</span>
                    <span class="n">spec</span><span class="o">.</span><span class="n">open_addr_field</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">spec</span><span class="o">.</span><span class="n">open_fields</span><span class="p">,</span>
                    <span class="n">open_cnt_name</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">open_id_field</span><span class="p">:</span>
                <span class="n">open_need</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">open_id_field</span><span class="p">)</span>
            <span class="c1"># Everything the close rule needs, plus fields we want at close (ID + resp if present)</span>
            <span class="n">close_need</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="o">*</span><span class="n">spec</span><span class="o">.</span><span class="n">close_rule</span><span class="o">.</span><span class="n">signals</span><span class="p">,</span>
                    <span class="n">spec</span><span class="o">.</span><span class="n">close_resp_field</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">spec</span><span class="o">.</span><span class="n">close_fields</span><span class="p">,</span>
                    <span class="n">close_cnt_name</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">close_id_field</span><span class="p">:</span>
                <span class="n">close_need</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">close_id_field</span><span class="p">)</span>
            <span class="n">open_map</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">open_need</span><span class="p">)</span>
            <span class="n">close_map</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">close_need</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">open_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">close_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">open_ctx</span> <span class="o">=</span> <span class="n">make_ctx</span><span class="p">(</span><span class="n">open_map</span><span class="p">)</span>
            <span class="n">close_ctx</span> <span class="o">=</span> <span class="n">make_ctx</span><span class="p">(</span><span class="n">close_map</span><span class="p">)</span>
            <span class="n">has_open_cnt</span> <span class="o">=</span> <span class="n">open_cnt_name</span> <span class="ow">in</span> <span class="n">open_map</span>
            <span class="n">has_close_cnt</span> <span class="o">=</span> <span class="n">close_cnt_name</span> <span class="ow">in</span> <span class="n">close_map</span>

            <span class="k">def</span> <span class="nf">derive_overflow_thresholds</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Per-ID FIFO for this spec</span>

            <span class="n">pending</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">deque</span><span class="p">[</span><span class="n">Transaction</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">deque</span><span class="p">)</span>
            <span class="n">completed</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Transaction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="c1"># Open: if rule fires, enqueue a Transaction with start_idx and fields</span>
                <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">open_rule</span><span class="o">.</span><span class="n">applies</span><span class="p">(</span><span class="n">open_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                    <span class="n">tid</span> <span class="o">=</span> <span class="n">to_int</span><span class="p">(</span><span class="n">open_ctx</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">open_id_field</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="ow">or</span> <span class="mi">0</span>
                    <span class="n">addr</span> <span class="o">=</span> <span class="n">to_int</span><span class="p">(</span><span class="n">open_ctx</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">open_addr_field</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                    <span class="n">resp</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">to_int</span><span class="p">(</span><span class="n">close_ctx</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">close_resp_field</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">close_resp_field</span>
                        <span class="k">else</span> <span class="kc">None</span>
                    <span class="p">)</span>
                    <span class="n">ticket</span> <span class="o">=</span> <span class="n">next_ticket</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span>
                    <span class="n">pending_by_id_ticket</span><span class="p">[</span><span class="n">tid</span><span class="p">][</span><span class="n">ticket</span><span class="p">]</span> <span class="o">=</span> <span class="n">Transaction</span><span class="p">(</span>
                        <span class="n">kind</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">txn_type</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">tid</span><span class="p">,</span> <span class="n">addr</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">start_idx</span><span class="o">=</span><span class="n">i</span>
                    <span class="p">)</span>
                    <span class="n">next_ticket</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">pending</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">Transaction</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">txn_type</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">tid</span><span class="p">,</span> <span class="n">addr</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">start_idx</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># Close: if rule fires, pop from that IDs queue and finalize</span>
                <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">close_rule</span><span class="o">.</span><span class="n">applies</span><span class="p">(</span><span class="n">close_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                    <span class="n">tid</span> <span class="o">=</span> <span class="n">to_int</span><span class="p">(</span><span class="n">close_ctx</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">close_id_field</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="ow">or</span> <span class="mi">0</span>
                    <span class="n">resp</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">to_int</span><span class="p">(</span><span class="n">close_ctx</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">close_resp_field</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">close_resp_field</span>
                        <span class="k">else</span> <span class="kc">None</span>
                    <span class="p">)</span>

                    <span class="c1"># I think 00 means good response.</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">has_close_cnt</span><span class="p">:</span>
                        <span class="n">cc</span> <span class="o">=</span> <span class="n">to_int</span><span class="p">(</span><span class="n">close_ctx</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">close_cnt_name</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">cc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># Oldest outstanding ticket (the one completing now)</span>
                            <span class="n">ticket_to_close</span> <span class="o">=</span> <span class="n">next_ticket</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">-</span> <span class="n">cc</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="n">pending_by_id_ticket</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ticket_to_close</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                    <span class="c1"># Fallback to FIFO if counters not present or lookup failed</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">dq</span> <span class="o">=</span> <span class="n">pending</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">dq</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="n">dq</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">end_idx</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">resp</span> <span class="o">=</span> <span class="n">resp</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">probes</span> <span class="o">=</span> <span class="p">(</span><span class="n">open_map</span> <span class="ow">or</span> <span class="p">{})</span> <span class="o">|</span> <span class="p">(</span><span class="n">close_map</span> <span class="ow">or</span> <span class="p">{})</span>
                        <span class="n">completed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Orphan close; ignore or record a violation if desired</span>
                        <span class="k">pass</span>

            <span class="n">txns_all</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">completed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transactions</span> <span class="o">=</span> <span class="n">txns_all</span>
        <span class="c1">#  self.append_per_id_binary_lanes(waveform, &quot;SLOT_&quot; + str(self.slot) if waveform.num_slots &gt; 1 else &quot;AXI&quot;)</span>
        <span class="k">return</span> <span class="n">txns_all</span>

    <span class="k">def</span> <span class="nf">write_gtkw_with_translate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">out_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;AXI&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write translate tables (.tt) and a .gtkw savefile for GTKWave that</span>
<span class="sd">        pipes each lane signal through its translate table.</span>

<span class="sd">        Args:</span>
<span class="sd">          transactions: list of Transaction; defaults to self.transactions.</span>
<span class="sd">          vcd_path: path to the VCD that contains the lane signals.</span>
<span class="sd">          out_dir: directory to write .tt files and the .gtkw file.</span>
<span class="sd">          name_prefix: lane name prefix (e.g., &quot;AXI4MM&quot; or &quot;AXI4MM_SLOT2&quot;).</span>
<span class="sd">          separate_by_kind: if True and channel_name missing, synthesize lanes per (ID, kind).</span>
<span class="sd">          gtkw_path: optional explicit output path for the .gtkw; defaults to &quot;&lt;out_dir&gt;/&lt;name_prefix&gt;.gtkw&quot;.</span>
<span class="sd">          hierarchy_prefix: optional VCD hierarchy prefix (e.g., &quot;top/dut/&quot;) to prepend to lane names in .gtkw.</span>

<span class="sd">        Returns:</span>
<span class="sd">          Absolute path to the generated .gtkw file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lanes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Helper to merge a single transaction into the lanes dict</span>
        <span class="k">def</span> <span class="nf">_merge_txn_lane</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">lane_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;channel_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">enum_map</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;enum&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># expected code -&gt; label</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lane_name</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">enum_map</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">lane_map</span> <span class="o">=</span> <span class="n">lanes</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">lane_name</span><span class="p">,</span> <span class="p">{})</span>
            <span class="c1"># Merge codes; keep first-seen label for determinism</span>
            <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">enum_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">lane_map</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="c1"># 1) Flatten transactions across slots (or fall back to asm.transactions)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactions</span><span class="p">:</span>
            <span class="n">_merge_txn_lane</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># 2) Normalize and attach to target_columns once per lane</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lanes</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

            <span class="c1"># 2) Write one .tt per lane in the desired format</span>
        <span class="n">written_files</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">lane_name</span><span class="p">,</span> <span class="n">code_to_label</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">lanes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="c1"># Ensure code 0 exists for idle</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">code_to_label</span><span class="p">:</span>
                <span class="n">code_to_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>

            <span class="c1"># Sort by code (value) ascending</span>
            <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">code_to_label</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Compute bit width from the max code</span>
            <span class="n">max_code</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">items</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">bit_width</span> <span class="o">=</span> <span class="n">max_code</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="k">if</span> <span class="n">max_code</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="c1"># Build lines in the requested format</span>
            <span class="n">output_lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="n">binary</span> <span class="o">=</span> <span class="nb">format</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;0</span><span class="si">{</span><span class="n">bit_width</span><span class="si">}</span><span class="s2">b&quot;</span><span class="p">)</span>
                <span class="c1"># Use &quot;&#39;&lt;label&gt;&quot; and map empty to NOEVENTS (or &#39;-&#39; if you prefer strictly &#39;-&#39;)</span>
                <span class="n">display_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">label</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">output_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">binary</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">display_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># File name per lane (change extension if you prefer .gtkw for a GTKW savefile)</span>
            <span class="n">tt_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lane_name</span><span class="si">}</span><span class="s2">.gtkw&quot;</span><span class="p">))</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tt_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_lines</span><span class="p">))</span>

            <span class="n">written_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tt_path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">written_files</span>


<div class="viewcode-block" id="ILAWaveform"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ILAWaveform</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Waveform data, with data probe information.&quot;&quot;&quot;</span>

    <span class="n">width</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample bit width.&quot;&quot;&quot;</span>
    <span class="n">sample_count</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of data samples.&quot;&quot;&quot;</span>
    <span class="n">trigger_position</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Trigger position index, for each data window.&quot;&quot;&quot;</span>
    <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of samples in a window.&quot;&quot;&quot;</span>

    <span class="n">probes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ILAWaveformProbe</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dict of {probe name, waveform probe}   See :class:`ILAWaveformProbe`&quot;&quot;&quot;</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">bytearray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Waveform data.</span>
<span class="sd">    Samples are aligned on byte boundary. </span>

<span class="sd">    This formula can be used to read a bit from the data:</span>
<span class="sd">    ::</span>

<span class="sd">        bytes_per_sample = len(data) // sample_count</span>

<span class="sd">        def get_bit_value(data: bytearray, bytes_per_sample: int,</span>
<span class="sd">                          sample_index: int, data_bit_index: int) -&gt; bool:</span>
<span class="sd">            byte_value = data[sample_index * bytes_per_sample + data_bit_index // 8]</span>
<span class="sd">            mask = 1 &lt;&lt; (data_bit_index &amp; 0x7)</span>
<span class="sd">            return (byte_value &amp; mask) != 0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gap_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    None or 0, if the waveform has no gaps. </span>
<span class="sd">    If the value is &gt;0, one sample bit is reserved to indicate which samples are gaps,</span>
<span class="sd">    i.e. the samples with unknown values. &#39;gap_index&#39; gives the bit location within the sample data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">probe_groups</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ProbeGroup</span><span class="p">]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">transactionAssembler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TopTransactionAssembler</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">num_slots</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">bytes_per_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># CR-1244881 - partial window captures are not framed correctly.</span>
        <span class="c1"># Changed so that all windows (partial or full) use the full window size</span>
        <span class="c1"># when calculating the offset for probes in a buffer. The ILA core</span>
        <span class="c1"># uploads an entire buffer regardless of partial of full window, so</span>
        <span class="c1"># alignment does not change for the last partial.</span>
        <span class="c1">#     old_result = len(self.data) // self.sample_count</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_leaf_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># Safely extract the last path segment and uppercase it for matching</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_match_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">prefixes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">leaf</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">prefixes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">pfx</span><span class="o">.</span><span class="n">upper</span><span class="p">()):</span>
                <span class="k">return</span> <span class="n">pfx</span>  <span class="c1"># group name == prefix</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_extract_slot_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probe_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract slot ID from probe name of the form:</span>
<span class="sd">          SLOT_&lt;n&gt;_.../...</span>
<span class="sd">        Returns the integer slot id if found, else None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Example: &quot;SLOT_4_AXI_AWVALID&quot; -&gt; slot 4</span>
        <span class="k">if</span> <span class="s2">&quot;cnt&quot;</span> <span class="ow">in</span> <span class="n">probe_name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;SLOT_(\d+)&quot;</span><span class="p">,</span> <span class="n">probe_name</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;SLOT_(\d+)&quot;</span><span class="p">,</span> <span class="n">probe_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">m</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_create_probe_groups</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prefixes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rules</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Rule&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">descriptions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">create_misc_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">misc_group_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;MISC&quot;</span><span class="p">,</span>
        <span class="n">slot</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;ProbeGroup&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create probe groups based on a list of signal name prefixes for a specific slot.</span>
<span class="sd">        Each prefix becomes a group. The first matching prefix (by list order) wins.</span>

<span class="sd">        If self.num_slots &gt; 1, only probes whose hierarchical name indicates the</span>
<span class="sd">        specified slot (e.g., &#39;SLOT_&lt;slot&gt;_.../LEAF&#39;) are included.</span>

<span class="sd">        Args:</span>
<span class="sd">            prefixes: List/sequence of prefixes, e.g., [&quot;AW&quot;, &quot;W&quot;, &quot;B&quot;, &quot;AR&quot;, &quot;R&quot;].</span>
<span class="sd">                      If None, defaults to AXI channels.</span>
<span class="sd">            rules: Optional list of Rule objects; assigned by the prefix match of the</span>
<span class="sd">                   rule&#39;s first signal. Rules are included only if their first signal</span>
<span class="sd">                   is from the specified slot.</span>
<span class="sd">            descriptions: Optional mapping of group name -&gt; description string.</span>
<span class="sd">            create_misc_group: If True, unmatched signals/rules are placed in a MISC group.</span>
<span class="sd">            misc_group_name: Name for the MISC group.</span>
<span class="sd">            slot: Slot index to build groups for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary of non-empty ProbeGroup objects keyed by group name for the given slot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default to AXI channel-style prefixes</span>
        <span class="k">if</span> <span class="n">prefixes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AW&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;AR&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">]</span>

        <span class="c1"># Initialize groups (group name == prefix)</span>
        <span class="n">groups</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ProbeGroup</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">prefixes</span><span class="p">:</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="n">descriptions</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pfx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pfx</span><span class="si">}</span><span class="s2"> Group&quot;</span><span class="p">)</span>
            <span class="n">groups</span><span class="p">[</span><span class="n">pfx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ProbeGroup</span><span class="p">(</span><span class="n">pfx</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>

        <span class="c1"># Populate groups with probes for the specified slot</span>
        <span class="k">for</span> <span class="n">probe_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If multiple slots exist, filter probes by the requested slot</span>
            <span class="c1"># Use leaf name for prefix matching (e.g., &quot;AWVALID&quot;)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_slots</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_slot_id</span><span class="p">(</span><span class="n">probe_name</span><span class="p">)</span> <span class="o">!=</span> <span class="n">slot</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaf_name</span><span class="p">(</span><span class="n">probe_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;cnt&quot;</span> <span class="ow">in</span> <span class="n">probe_name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="n">leaf</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">leaf</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">group_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_prefix</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">prefixes</span><span class="p">)</span>
            <span class="c1"># Example: &quot;SLOT_4_AXI_AWVALID&quot; -&gt; slot 4</span>

            <span class="k">if</span> <span class="n">group_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">groups</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span><span class="o">.</span><span class="n">add_probe</span><span class="p">(</span><span class="n">probe_name</span><span class="p">)</span>

        <span class="c1"># Attach rules, if any (only rules whose first signal is in this slot)</span>
        <span class="k">if</span> <span class="n">rules</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
                <span class="n">group_key</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="s2">&quot;signals&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">first_signal</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">first_signal_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaf_name</span><span class="p">(</span><span class="n">first_signal</span><span class="p">)</span>
                    <span class="n">group_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_prefix</span><span class="p">(</span><span class="n">first_signal_leaf</span><span class="p">,</span> <span class="n">prefixes</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">group_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">group_key</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>

        <span class="c1"># Build result with only non-empty groups</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ProbeGroup</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">group</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">}</span>

        <span class="c1"># Calculate values for groups that have rules</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s2">&quot;rules&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">rules</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">group</span><span class="o">.</span><span class="n">calculate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slot</span><span class="o">=</span><span class="n">slot</span><span class="p">)</span>
        <span class="c1"># breakpoint()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">create_protocol_waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">rules</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Rule</span><span class="p">]],</span> <span class="n">probe_prefixes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_experimental</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_slots</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_probe_groups</span><span class="p">(</span><span class="n">prefixes</span><span class="o">=</span><span class="n">probe_prefixes</span><span class="p">,</span> <span class="n">rules</span><span class="o">=</span><span class="n">rules</span><span class="p">,</span> <span class="n">slot</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">group</span><span class="o">.</span><span class="n">create_interval_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slot</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_transactions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;TransactionSpec&quot;</span><span class="p">],</span> <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Transaction&quot;</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_experimental</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">TopTransactionAssembler</span><span class="p">(</span><span class="n">specs</span><span class="o">=</span><span class="n">specs</span><span class="p">,</span> <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">)</span>

            <span class="c1"># Decode all slots</span>
            <span class="n">txns_by_slot</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># Render per-slot lanes</span>
            <span class="n">top</span><span class="o">.</span><span class="n">append_lanes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">separate_by_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">txns_by_slot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

<div class="viewcode-block" id="ILAWaveform.append_manual_enum_signal"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.append_manual_enum_signal">[docs]</a>    <span class="k">def</span> <span class="nf">append_manual_enum_signal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a multibit manual signal to an ILAWaveform, using an Enum display.</span>

<span class="sd">        Now supports emptystring labels by automatically giving them a valid</span>
<span class="sd">        enum member name under the hood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sanity checks</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: must supply one value per sample (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_count</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: no mapping for </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># -- step 1: build a &quot;sanitized&quot; mapping that Enum() will accept --</span>
        <span class="c1">#    we also keep a reversemap so we can show the original strings.</span>
        <span class="n">enum_to_display</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sanitized_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># pick a valid Python identifier for the enum member</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">member_name</span> <span class="o">=</span> <span class="n">label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># e.g. &#39;&#39;  &#39;_EMPTY&#39;, or anything else that isn&#39;t a valid name</span>
                <span class="n">member_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;VAL_</span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">sanitized_map</span><span class="p">[</span><span class="n">member_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>
            <span class="n">enum_to_display</span><span class="p">[</span><span class="n">member_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
        <span class="c1"># determine code width</span>
        <span class="n">max_code</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sanitized_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">bit_width</span> <span class="o">=</span> <span class="n">max_code</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="ow">or</span> <span class="mi">1</span>

        <span class="c1"># assign bitrange</span>
        <span class="n">old_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>
        <span class="n">bit_index</span> <span class="o">=</span> <span class="n">old_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">old_width</span> <span class="o">+</span> <span class="n">bit_width</span>

        <span class="c1"># RESIZE THE DATA BUFFER TO ACCOMMODATE NEW BITS</span>
        <span class="n">old_bps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytes_per_sample</span><span class="p">()</span>
        <span class="n">new_bps</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span>  <span class="c1"># Calculate new bytes per sample</span>

        <span class="k">if</span> <span class="n">new_bps</span> <span class="o">&gt;</span> <span class="n">old_bps</span><span class="p">:</span>
            <span class="c1"># Need to expand the data buffer</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">new_bps</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_count</span><span class="p">)</span>
            <span class="c1"># Copy old data sample by sample</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_count</span><span class="p">):</span>
                <span class="n">old_start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">old_bps</span>
                <span class="n">old_end</span> <span class="o">=</span> <span class="n">old_start</span> <span class="o">+</span> <span class="n">old_bps</span>
                <span class="n">new_start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">new_bps</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">new_start</span> <span class="p">:</span> <span class="n">new_start</span> <span class="o">+</span> <span class="n">old_bps</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">old_start</span><span class="p">:</span><span class="n">old_end</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>

        <span class="c1"># create the Enum class with the format expected by decode_waveform_from_json</span>
        <span class="n">enum_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_Enum&quot;</span>
        <span class="n">EnumDef</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="n">enum_name</span><span class="p">,</span> <span class="n">sanitized_map</span><span class="p">)</span>

        <span class="c1"># Store the enum in the format that can be serialized/deserialized correctly</span>
        <span class="c1"># The JSON decoder expects: [&quot;EnumName&quot;, {&quot;member1&quot;: value1, &quot;member2&quot;: value2}]</span>
        <span class="n">enum_def_serializable</span> <span class="o">=</span> <span class="p">[</span><span class="n">enum_name</span><span class="p">,</span> <span class="n">sanitized_map</span><span class="p">]</span>
        <span class="c1"># build the probe</span>
        <span class="n">probe</span> <span class="o">=</span> <span class="n">ILAWaveformProbe</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="nb">map</span><span class="o">=</span><span class="s2">&quot;manual&quot;</span><span class="p">,</span>
            <span class="n">map_range</span><span class="o">=</span><span class="p">[</span><span class="n">ILABitRange</span><span class="p">(</span><span class="n">bit_index</span><span class="p">,</span> <span class="n">bit_width</span><span class="p">)],</span>
            <span class="n">is_bus</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">bus_left_index</span><span class="o">=</span><span class="n">bit_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">bus_right_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">display_radix</span><span class="o">=</span><span class="n">ILAProbeRadix</span><span class="o">.</span><span class="n">ENUM</span><span class="p">,</span>
            <span class="n">enum_def</span><span class="o">=</span><span class="n">EnumDef</span><span class="p">,</span>  <span class="c1"># Store the actual Enum class</span>
        <span class="p">)</span>

        <span class="c1"># Store serialization info and display map for later use</span>
        <span class="n">probe</span><span class="o">.</span><span class="n">_enum_def_serializable</span> <span class="o">=</span> <span class="n">enum_def_serializable</span>  <span class="c1"># For JSON export</span>
        <span class="n">probe</span><span class="o">.</span><span class="n">_display_map</span> <span class="o">=</span> <span class="n">enum_to_display</span>  <span class="c1"># For showing original labels</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">probe</span>

        <span class="c1"># inject the bits - now use the new bytes_per_sample</span>
        <span class="n">bps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytes_per_sample</span><span class="p">()</span>  <span class="c1"># This will return the NEW bps</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="c1"># find the sanitized member name that produced this label</span>
            <span class="k">for</span> <span class="n">member_name</span><span class="p">,</span> <span class="n">disp</span> <span class="ow">in</span> <span class="n">enum_to_display</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">disp</span> <span class="o">==</span> <span class="n">sval</span><span class="p">:</span>
                    <span class="n">code</span> <span class="o">=</span> <span class="n">sanitized_map</span><span class="p">[</span><span class="n">member_name</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># should never happensanity check</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no enum member for </span><span class="si">{</span><span class="n">sval</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">base</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">bps</span>
            <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bit_width</span><span class="p">):</span>
                <span class="n">byte_off</span> <span class="o">=</span> <span class="p">(</span><span class="n">bit_index</span> <span class="o">+</span> <span class="n">bit</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">bit_index</span> <span class="o">+</span> <span class="n">bit</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">byte_off</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span></div>

    <span class="k">def</span> <span class="nf">get_window_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">)</span>

<div class="viewcode-block" id="ILAWaveform.set_sample"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.set_sample">[docs]</a>    <span class="k">def</span> <span class="nf">set_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="nb">bytearray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample may have more bytes than waveform samples have. Erase any gap bit.&quot;&quot;&quot;</span>
        <span class="n">sample_byte_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytes_per_sample</span><span class="p">()</span>
        <span class="n">copy_byte_count</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sample_byte_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">sample_byte_count</span> <span class="o">*</span> <span class="n">sample_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">copy_byte_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">copy_byte_count</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap_index</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">gap_byte_index</span><span class="p">,</span> <span class="n">gap_bit_index</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xFF</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gap_bit_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">gap_byte_index</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="ILAWaveform.export_waveform"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.export_waveform">[docs]</a>    <span class="k">def</span> <span class="nf">export_waveform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">export_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CSV&quot;</span><span class="p">,</span>
        <span class="n">fh_or_filepath</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TextIOBase</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
        <span class="n">probe_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_DEFLATED</span><span class="p">,</span>
        <span class="n">compresslevel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export a waveform in CSV, VCD or CITF format, to a file or in-memory buffer.</span>
<span class="sd">        By default, all samples for all probes are exported, but it is</span>
<span class="sd">        possible to select which probes and window/sample ranges for CSV/VCD formats.</span>

<span class="sd">        ================================ ======================== ==============================</span>
<span class="sd">        Argument/Parameter               Type                     Supported by Export Format</span>
<span class="sd">        ================================ ======================== ==============================</span>
<span class="sd">        export_format                    str                      CSV, VCD, CITF</span>
<span class="sd">        fh_or_filepath                   TextIOBase               CSV, VCD</span>
<span class="sd">        fh_or_filepath                   BytesIO                            CITF</span>
<span class="sd">        fh_or_filepath                   str                      CSV, VCD, CITF</span>
<span class="sd">        probe_names                      List[str]                CSV, VCD</span>
<span class="sd">        start_window                     int                      CSV, VCD</span>
<span class="sd">        start_sample_idx                 int                      CSV, VCD</span>
<span class="sd">        sample_count                     int                      CSV, VCD</span>
<span class="sd">        include_gap                      bool                     CSV, VCD</span>
<span class="sd">        include_gap                      bool                     CSV, VCD</span>
<span class="sd">        compression                      int                                CITF</span>
<span class="sd">        compresslevel                    int                                CITF</span>
<span class="sd">        ================================ ======================== ==============================</span>


<span class="sd">        Args:</span>
<span class="sd">            export_format (str):  Alternatives for output format.</span>

<span class="sd">                - &#39;CSV&#39; - Comma Separated Value Format. Default.</span>
<span class="sd">                - &#39;VCD&#39; - Value Change Dump.</span>
<span class="sd">                - &#39;CITF&#39; - ChipScoPy ILA Trace Format. Export of a whole ILA waveform to a compressed archive.</span>


<span class="sd">            fh_or_filepath (TextIOBase, BytesIO, str): File object handle or filepath string. Default is `sys.stdout`.</span>
<span class="sd">                If the argument is a file object, closing and opening the file is the responsibility of the caller.</span>
<span class="sd">                If argument is a string, the file will be opened and closed by the function.</span>

<span class="sd">            probe_names (Optional[List[str]]): List of probe names. Default &#39;None&#39; means export all probes.</span>
<span class="sd">            start_window_idx (int): Starting window index. Default is first window.</span>
<span class="sd">            window_count (Optional[int]): Number of windows to export. Default is all windows.</span>
<span class="sd">            start_sample_idx (int): Starting sample within window. Default is first sample.</span>
<span class="sd">            sample_count (Optional[int]): Number of samples per window. Default is all samples.</span>
<span class="sd">            include_gap (bool):  Default is False. Include the pseudo &quot;gap&quot; 1-bit probe in the result.</span>
<span class="sd">            compression: Default is zipfile.ZIP_DEFLATED. See zipfile.ZipFile at https://docs.python.org/.</span>
<span class="sd">            compresslevel: See zipfile.ZipFile at https://docs.python.org/.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;CITF&quot;</span><span class="p">:</span>
            <span class="n">export_compressed_waveform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fh_or_filepath</span><span class="p">,</span> <span class="n">compression</span><span class="p">,</span> <span class="n">compresslevel</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;VCD&quot;</span> <span class="ow">and</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;CSV&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;ILAWaveform.export() called with unknown export_format:&quot;</span><span class="si">{</span><span class="n">export_format</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
                <span class="s2">&quot;Supported export formats are VCD, CSV and CITF.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fh_or_filepath</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fh_or_filepath</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=</span><span class="mi">16384</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">export_waveform_to_stream</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">export_format</span><span class="p">,</span>
                    <span class="n">fh</span><span class="p">,</span>
                    <span class="n">probe_names</span><span class="p">,</span>
                    <span class="n">start_window_idx</span><span class="p">,</span>
                    <span class="n">window_count</span><span class="p">,</span>
                    <span class="n">start_sample_idx</span><span class="p">,</span>
                    <span class="n">sample_count</span><span class="p">,</span>
                    <span class="n">include_gap</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;CSV&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_probe_group_enums_to_csv</span><span class="p">(</span><span class="n">fh_or_filepath</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;VCD&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">[</span>
                    <span class="mi">0</span>
                <span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>  <span class="c1"># This will have to be later updated. Just too clunky to be used rn.</span>
                    <span class="n">pg</span><span class="o">.</span><span class="n">write_enum_mappings_to_text_file</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.gtkw&quot;</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">enum_mappings</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactionAssembler</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transactionAssembler</span><span class="o">.</span><span class="n">write_gtkw_translate</span><span class="p">(</span>
                        <span class="n">vcd_path</span><span class="o">=</span><span class="n">fh_or_filepath</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="s2">&quot;gtkw_files&quot;</span><span class="p">,</span> <span class="n">separate_by_kind</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">export_waveform_to_stream</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">export_format</span><span class="p">,</span>
                <span class="n">fh_or_filepath</span><span class="p">,</span>
                <span class="n">probe_names</span><span class="p">,</span>
                <span class="n">start_window_idx</span><span class="p">,</span>
                <span class="n">window_count</span><span class="p">,</span>
                <span class="n">start_sample_idx</span><span class="p">,</span>
                <span class="n">sample_count</span><span class="p">,</span>
                <span class="n">include_gap</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;CSV&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_probe_group_enums_to_csv</span><span class="p">(</span><span class="n">fh_or_filepath</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;VCD&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">pg</span><span class="o">.</span><span class="n">write_enum_mappings_to_text_file</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.gtkw&quot;</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">enum_mappings</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactionAssembler</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transactionAssembler</span><span class="o">.</span><span class="n">write_gtkw_translate</span><span class="p">(</span>
                        <span class="n">vcd_path</span><span class="o">=</span><span class="n">fh_or_filepath</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="s2">&quot;gtkw_files&quot;</span><span class="p">,</span> <span class="n">separate_by_kind</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="ILAWaveform.apply_probe_group_enums_to_csv"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.apply_probe_group_enums_to_csv">[docs]</a>    <span class="k">def</span> <span class="nf">apply_probe_group_enums_to_csv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">csv_in_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process a CSV: replace numeric values in ProbeGroup signal columns with enum labels.</span>

<span class="sd">        Args:</span>
<span class="sd">            csv_in_path: Path to the input CSV (already exported).</span>
<span class="sd">            csv_out_path: Path to write the updated CSV. If None, overwrites csv_in_path.</span>
<span class="sd">            probe_groups: Dict of ProbeGroup where each group has:</span>
<span class="sd">                - signal_name: str - the column header to target</span>
<span class="sd">                - enum_mappings: Dict[str, int] - mapping label -&gt; code</span>
<span class="sd">            idle_label: Label used when a mapping resolves to an empty string or missing label.</span>
<span class="sd">            strict: If True, raises on missing columns or unparsable numeric values. Otherwise logs and passes through.</span>

<span class="sd">        Behavior:</span>
<span class="sd">            - Keeps comment lines starting with &#39;#&#39; intact.</span>
<span class="sd">            - Finds the header row (first non-comment row) and replaces values only in columns whose header matches</span>
<span class="sd">              a group&#39;s signal_name.</span>
<span class="sd">            - Expected CSV cell values are integers (decimal or 0x-prefixed hex). If a value is already non-numeric,</span>
<span class="sd">              it will be left as-is unless strict=True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">csv_out_path</span> <span class="o">=</span> <span class="n">csv_in_path</span>  <span class="c1"># overwrite</span>

        <span class="c1"># 1) Read all lines</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_in_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="c1"># 2) Identify header line (first non-comment)</span>
        <span class="n">header_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                <span class="n">header_idx</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">header_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No header row found (no non-comment lines).&quot;</span><span class="p">)</span>

        <span class="c1"># 3) Parse header</span>
        <span class="n">header</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">([</span><span class="n">lines</span><span class="p">[</span><span class="n">header_idx</span><span class="p">]]))</span>
        <span class="n">col_index_by_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">header</span><span class="p">)}</span>

        <span class="c1"># 4) For each ProbeGroup, find target column and build reverse mapping (code -&gt; label)</span>
        <span class="c1">#    Also collect display override if ProbeGroup stores it (optional).</span>
        <span class="n">target_columns</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;Tuple&quot;</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">_find_col_index_by_prefix</span><span class="p">(</span><span class="n">header</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">signal_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
            <span class="c1"># Exact match first</span>
            <span class="k">if</span> <span class="n">signal_name</span> <span class="ow">in</span> <span class="n">col_index_by_name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">col_index_by_name</span><span class="p">[</span><span class="n">signal_name</span><span class="p">]</span>
            <span class="c1"># Case-insensitive startswith fallback</span>
            <span class="n">sig_lower</span> <span class="o">=</span> <span class="n">signal_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">sig_lower</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># If multiple candidates, prefer the shortest name or the one equal ignoring case</span>
                <span class="n">exact_ci</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">sig_lower</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">exact_ci</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">exact_ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Otherwise pick the shortest match deterministically</span>
                <span class="n">shortest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">shortest</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">slot_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_groups</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">pg</span> <span class="ow">in</span> <span class="n">slot_group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">signal_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="s2">&quot;channel_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">enum_mapping</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="s2">&quot;enum_mappings&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># label -&gt; code</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">signal_name</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">enum_mapping</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">col_idx</span> <span class="o">=</span> <span class="n">_find_col_index_by_prefix</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">signal_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">col_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Signal column &#39;</span><span class="si">{</span><span class="n">signal_name</span><span class="si">}</span><span class="s2">&#39; not found in CSV header.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Skip this group if column not present</span>
                        <span class="k">continue</span>

                <span class="c1"># Invert mapping: code -&gt; label</span>
                <span class="n">code_to_label</span> <span class="o">=</span> <span class="p">{</span><span class="n">code</span><span class="p">:</span> <span class="n">label</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">enum_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">target_columns</span><span class="p">[</span><span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">signal_name</span><span class="p">,</span> <span class="n">code_to_label</span><span class="p">)</span>
        <span class="n">lanes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactionAssembler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Aggregate per-lane enum mappings from all transactions (across slots)</span>
            <span class="n">lanes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">asm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactionAssembler</span>
            <span class="n">txns_by_slot</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">asm</span><span class="p">,</span> <span class="s2">&quot;transactions_by_slot&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Helper to merge a single transaction into the lanes dict</span>
            <span class="k">def</span> <span class="nf">_merge_txn_lane</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="n">lane_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;channel_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">enum_map</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;enum&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># expected code -&gt; label</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lane_name</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">enum_map</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">lane_map</span> <span class="o">=</span> <span class="n">lanes</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">lane_name</span><span class="p">,</span> <span class="p">{})</span>
                <span class="c1"># Merge codes; keep first-seen label for determinism</span>
                <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">enum_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">lane_map</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

            <span class="c1"># 1) Flatten transactions across slots (or fall back to asm.transactions)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">txns_by_slot</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">slot</span><span class="p">,</span> <span class="n">txns</span> <span class="ow">in</span> <span class="n">txns_by_slot</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">txns</span><span class="p">:</span>
                        <span class="n">_merge_txn_lane</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">asm</span><span class="p">,</span> <span class="s2">&quot;transactions&quot;</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="n">_merge_txn_lane</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="c1"># 2) Normalize and attach to target_columns once per lane</span>
            <span class="k">for</span> <span class="n">lane_name</span><span class="p">,</span> <span class="n">code_to_label</span> <span class="ow">in</span> <span class="n">lanes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Ensure a code 0 mapping exists (choose label convention to match your CSV tools)</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">code_to_label</span><span class="p">:</span>
                    <span class="n">code_to_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>  <span class="c1"># or &quot;-&quot; if thats what your exporter expects</span>

                <span class="n">col_idx</span> <span class="o">=</span> <span class="n">_find_col_index_by_prefix</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">lane_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">col_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">target_columns</span><span class="p">[</span><span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lane_name</span><span class="p">,</span> <span class="n">code_to_label</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">strict</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Transaction lane column &#39;</span><span class="si">{</span><span class="n">lane_name</span><span class="si">}</span><span class="s2">&#39; not found in CSV header.&quot;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">target_columns</span><span class="p">:</span>
            <span class="c1"># No work to do; just copy file</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_out_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfh</span><span class="p">:</span>
                <span class="n">outfh</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># 5) Helper: parse numeric value (supports int or hex like 0x..)</span>
        <span class="k">def</span> <span class="nf">parse_code</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># 6) Write out modified CSV</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_out_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfh</span><span class="p">:</span>
            <span class="c1"># Copy any leading comment lines unchanged</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header_idx</span><span class="p">):</span>
                <span class="n">outfh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">outfh</span><span class="p">)</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

            <span class="c1"># Process rows after header</span>
            <span class="k">for</span> <span class="n">raw_line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="n">header_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]:</span>
                <span class="c1"># Keep empty or comment-like lines intact</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">raw_line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                    <span class="n">outfh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">raw_line</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">([</span><span class="n">raw_line</span><span class="p">]))</span>
                <span class="c1"># Ensure row has at least as many columns as header (pad if necessary)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
                    <span class="n">row</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>

                <span class="c1"># For each target column, map numeric code -&gt; text label</span>
                <span class="k">for</span> <span class="n">col_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">signal_name</span><span class="p">,</span> <span class="n">code_to_label</span><span class="p">)</span> <span class="ow">in</span> <span class="n">target_columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">cell</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">col_idx</span><span class="p">]</span>

                    <span class="n">code</span> <span class="o">=</span> <span class="n">parse_code</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
                    <span class="c1"># if col_idx == 45 and cell == &#39;0A&#39;:</span>
                    <span class="c1">#     breakpoint()</span>
                    <span class="k">if</span> <span class="n">code</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># If non-numeric leave as-is.</span>
                        <span class="c1"># if col_idx == 45:</span>
                        <span class="c1">#     breakpoint()</span>
                        <span class="k">continue</span>

                    <span class="n">label</span> <span class="o">=</span> <span class="n">code_to_label</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>

                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">row</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">import_waveform</span><span class="p">(</span>
        <span class="n">import_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">filepath_or_buffer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an ILAWaveform object from a ChipScoPy ILA Trace Format (CITF) compressed archive.</span>
<span class="sd">        The archive must contain these two files:</span>

<span class="sd">            - waveform.cfg, waveform and probe meta information.</span>
<span class="sd">            - waveform.data, binary waveform samples.</span>

<span class="sd">        Args:</span>
<span class="sd">            import_format (str): Format &quot;CITF&quot; is supported.</span>
<span class="sd">            filepath_or_buffer (str, BytesIO): Filepath string or in-memory buffer.</span>

<span class="sd">        Returns (ILAWaveform):</span>
<span class="sd">            Waveform object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">import_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;CITF&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;import_waveform command called with import_format &quot;</span><span class="si">{</span><span class="n">import_format</span><span class="si">}</span><span class="s1">&quot;.&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; Only &quot;CITF&quot; format is supported.&#39;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">import_compressed_waveform</span><span class="p">(</span><span class="n">filepath_or_buffer</span><span class="p">)</span>

<div class="viewcode-block" id="ILAWaveform.get_data"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">probe_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_trigger</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">include_sample_info</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get probe waveform data as a list of int values for each probe.</span>
<span class="sd">        By default, all samples for all probes are included in return data,</span>
<span class="sd">        but it is possible to select which probes and window/sample ranges.</span>

<span class="sd">        Args:</span>
<span class="sd">            probe_names (Optional[List[str]]): List of probe names. Default &#39;None&#39; means export all probes.</span>
<span class="sd">            start_window_idx (int): Starting window index. Default is first window.</span>
<span class="sd">            window_count (Optional[int]): Number of windows to export. Default is all windows.</span>
<span class="sd">            start_sample_idx (int): Starting sample within window. Default is first sample.</span>
<span class="sd">            sample_count (Optional[int]): Number of samples per window. Default is all samples.</span>
<span class="sd">            include_trigger (bool): Include pseudo probe with name &#39;__TRIGGER&#39; in result. Default is False.</span>
<span class="sd">            include_sample_info (bool):  Default is False. Include the following pseudo probes in result:</span>

<span class="sd">              - &#39;__SAMPLE_INDEX&#39; - Sample index</span>
<span class="sd">              - &#39;__WINDOW_INDEX&#39; - Window index.</span>
<span class="sd">              - &#39;__WINDOW_SAMPLE_INDEX&#39; - Sample index within window.</span>

<span class="sd">            include_gap (bool):  Default is False. If True, include the pseudo probe &#39;__GAP&#39; in result. \</span>
<span class="sd">                                 Value 1 for a gap sample. Value 0 for a regular sample.</span>


<span class="sd">        Returns (Dict[str, List[int]]):</span>
<span class="sd">            Ordered dict, in order:</span>
<span class="sd">              - &#39;__TRIGGER&#39;, if argument **include_trigger** is True</span>
<span class="sd">              - &#39;__SAMPLE_INDEX&#39;, if argument **include_sample_info** is True</span>
<span class="sd">              - &#39;__WINDOW_INDEX&#39;, if argument **include_sample_info** is True</span>
<span class="sd">              - &#39;__WINDOW_SAMPLE_INDEX&#39;, if argument **include_sample_info** is True</span>
<span class="sd">              - &#39;__GAP&#39;, if argument **include_gap** is True</span>
<span class="sd">              - probe values in order of argument **probe_names**.</span>

<span class="sd">            Dict key: probe name. Dict value is list of int values, for a probe.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_waveform_data_values</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">probe_names</span><span class="p">,</span>
            <span class="n">start_window_idx</span><span class="p">,</span>
            <span class="n">window_count</span><span class="p">,</span>
            <span class="n">start_sample_idx</span><span class="p">,</span>
            <span class="n">sample_count</span><span class="p">,</span>
            <span class="n">include_trigger</span><span class="p">,</span>
            <span class="n">include_sample_info</span><span class="p">,</span>
            <span class="n">include_gap</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ILAWaveform.get_probe_data"><a class="viewcode-back" href="../../../../ila.html#chipscopy.api.ila.ILAWaveform.get_probe_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_probe_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">probe_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get waveform data as a list of int values for one probe.</span>
<span class="sd">        By default, all samples for the probe are returned,</span>
<span class="sd">        It is possible to select window range and sample range.</span>

<span class="sd">        Args:</span>
<span class="sd">            probe_name (str): probe name.</span>
<span class="sd">            start_window_idx (int): Starting window index. Default is first window.</span>
<span class="sd">            window_count (Optional[int]): Number of windows to export. Default is all windows.</span>
<span class="sd">            start_sample_idx (int): Starting sample within window. Default is first sample.</span>
<span class="sd">            sample_count (Optional[int]): Number of samples per window. Default is all samples.</span>

<span class="sd">        Returns (List[int]):</span>
<span class="sd">            List probe values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_dict</span> <span class="o">=</span> <span class="n">get_waveform_data_values</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="p">[</span><span class="n">probe_name</span><span class="p">],</span>
            <span class="n">start_window_idx</span><span class="p">,</span>
            <span class="n">window_count</span><span class="p">,</span>
            <span class="n">start_sample_idx</span><span class="p">,</span>
            <span class="n">sample_count</span><span class="p">,</span>
            <span class="n">include_trigger</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">include_sample_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">include_gap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">res_dict</span><span class="p">[</span><span class="n">probe_name</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;data&quot;</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">pformat</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">data_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">json_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
            <span class="s2">&quot;sample_count&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_count</span><span class="p">,</span>
            <span class="s2">&quot;trigger_position&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">,</span>
            <span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span>
            <span class="s2">&quot;probes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">asdict</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="s2">&quot;data size&quot;</span><span class="p">:</span> <span class="nb">hex</span><span class="p">(</span><span class="n">data_size</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">json_dict</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Enum2StrEncoder</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">get_txn_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactionAssembler</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transactionAssembler</span><span class="o">.</span><span class="n">get_transactions_by_slot</span><span class="p">()</span>

        <span class="n">slot_txns</span> <span class="o">=</span> <span class="n">transactions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">read_txns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">t</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">slot_txns</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;kind&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">kind</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;end_idx&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">read_txns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No completed read transactions in slot 0&quot;</span><span class="p">)</span>
        <span class="n">start_sample_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">start_idx</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">read_txns</span><span class="p">)</span>
        <span class="n">latest_end_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">end_idx</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">read_txns</span><span class="p">)</span>
        <span class="n">sample_count</span> <span class="o">=</span> <span class="n">latest_end_idx</span> <span class="o">-</span> <span class="n">start_sample_idx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">sample_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid sample range: start=</span><span class="si">{</span><span class="n">start_sample_idx</span><span class="si">}</span><span class="s2">, end=</span><span class="si">{</span><span class="n">latest_end_idx</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">unique_probes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_add_probe</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">unique_probes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">read_txns</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">probes</span>
            <span class="k">for</span> <span class="n">full</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">_add_probe</span><span class="p">(</span><span class="n">full</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">unique_probes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No probe names found on read transactions&quot;</span><span class="p">)</span>

        <span class="c1"># Render per-slot lanes</span>
        <span class="n">pdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span>
            <span class="n">probe_names</span><span class="o">=</span><span class="n">unique_probes</span><span class="p">,</span> <span class="n">start_sample_idx</span><span class="o">=</span><span class="n">start_sample_idx</span><span class="p">,</span> <span class="n">sample_count</span><span class="o">=</span><span class="n">sample_count</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">pdata</span></div>


<span class="k">def</span> <span class="nf">tcf_get_waveform_data</span><span class="p">(</span><span class="n">tcf_node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{}:</span>
    <span class="n">tcf_props</span> <span class="o">=</span> <span class="n">tcf_node</span><span class="o">.</span><span class="n">get_property_group</span><span class="p">([</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
    <span class="n">props</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_width&quot;</span><span class="p">],</span>
        <span class="s2">&quot;sample_count&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_sample_count&quot;</span><span class="p">],</span>
        <span class="s2">&quot;trigger_position&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_trigger_position&quot;</span><span class="p">],</span>
        <span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_window_size&quot;</span><span class="p">],</span>
        <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">tcf_props</span><span class="p">[</span><span class="s2">&quot;trace_data&quot;</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">props</span>


<span class="k">class</span> <span class="nc">WaveformWriter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TextIOBase</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handle</span> <span class="o">=</span> <span class="n">file_handle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probes</span> <span class="o">=</span> <span class="n">probes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probe_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probe_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_probe_names</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probe_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TextIOBase</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handle</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">make_values_unknown</span><span class="p">(</span><span class="n">in_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">unknown_ch</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">unknown_ch</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">in_values</span><span class="p">]</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">make_probe_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probes</span><span class="p">]</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">write_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_position</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">sample_in_window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">probe_binary_reversed_values</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">is_last_sample</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            sample_position (int):</span>
<span class="sd">            window_index (int):</span>
<span class="sd">            sample_in_window_index (int):</span>
<span class="sd">            is_trigger (bool):</span>
<span class="sd">            probe_binary_reversed_values ([str]): binary string values each start lsb at position zero.</span>
<span class="sd">            is_last_sample(bool): Last sample in waveform.</span>
<span class="sd">            is_gap (bool): True ig no data available for the sample.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">WaveformWriterCSV</span><span class="p">(</span><span class="n">WaveformWriter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">:</span> <span class="n">TextIOBase</span><span class="p">,</span> <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">],</span> <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">WaveformWriter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">,</span> <span class="n">probes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span> <span class="o">=</span> <span class="n">include_gap</span>

    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Sample in Buffer,Sample in Window,TRIGGER,&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;GAP,&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_probe_names</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Radix - UNSIGNED,UNSIGNED,UNSIGNED,&quot;</span><span class="p">)</span>
        <span class="c1"># Currently, HEX is the only supported radix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;HEX&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_count</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_probe_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">bus_range_str</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">write_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_position</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">sample_in_window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">probe_binary_reversed_values</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">is_last_sample</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hex_values</span> <span class="o">=</span> <span class="n">bin_reversed_to_hex_values</span><span class="p">(</span><span class="n">probe_binary_reversed_values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_gap</span><span class="p">:</span>
            <span class="n">hex_values</span> <span class="o">=</span> <span class="n">WaveformWriter</span><span class="o">.</span><span class="n">make_values_unknown</span><span class="p">(</span><span class="n">hex_values</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">hex_values_str</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hex_values</span><span class="p">)</span>
        <span class="n">trig_mark</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">is_trigger</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span><span class="p">:</span>
            <span class="n">gap_value</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">is_gap</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sample_position</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">sample_in_window_index</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">trig_mark</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">gap_value</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">hex_values_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sample_position</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">sample_in_window_index</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">trig_mark</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">hex_values_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">WaveformWriterToDict</span><span class="p">(</span><span class="n">WaveformWriter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">],</span>
        <span class="n">include_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">include_sample_info</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">WaveformWriter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">probes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_trigger</span> <span class="o">=</span> <span class="n">include_trigger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_sample_info</span> <span class="o">=</span> <span class="n">include_sample_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span> <span class="o">=</span> <span class="n">include_gap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result</span>

    <span class="k">def</span> <span class="nf">write_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_position</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">sample_in_window_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">probe_binary_reversed_values</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">is_last_sample</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_trigger</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__TRIGGER&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_trigger</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_sample_info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__SAMPLE_INDEX&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_position</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__WINDOW_INDEX&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">window_index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__WINDOW_SAMPLE_INDEX&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_in_window_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="s2">&quot;__GAP&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_gap</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">int_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">r_val</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">r_val</span> <span class="ow">in</span> <span class="n">probe_binary_reversed_values</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">probe_name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_probe_names</span><span class="p">,</span> <span class="n">int_values</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">[</span><span class="n">probe_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">WaveformWriterVCD</span><span class="p">(</span><span class="n">WaveformWriter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Value Change Dump format. See Wikipedia and IEEE Std 1364-2001.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">:</span> <span class="n">TextIOBase</span><span class="p">,</span> <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">],</span> <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">WaveformWriter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">,</span> <span class="n">probes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trigger_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gap_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span> <span class="o">=</span> <span class="n">include_gap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_trigger</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev_window_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_gap</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_vars</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Supports up to 94 + 94*94 + 94*94*94 = 839,514 probes (or variables).&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="nb">chr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">yy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="nb">chr</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xxx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">yyy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">zzz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="nb">chr</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">yyy</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">zzz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_variable_definitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">generate_vars</span> <span class="o">=</span> <span class="n">WaveformWriterVCD</span><span class="o">.</span><span class="n">_generate_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trigger_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gap_var</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">islice</span><span class="p">(</span>
            <span class="n">generate_vars</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_probe_count</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">width</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">probe_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_probe_widths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_names</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;$var reg </span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">probe_name</span><span class="si">}</span><span class="s2"> $end</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;$var reg 1 </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_trigger_var</span><span class="si">}</span><span class="s2"> _TRIGGER $end</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;$var reg 1 </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_var</span><span class="si">}</span><span class="s2"> _WINDOW $end</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;$var reg 1 </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_gap_var</span><span class="si">}</span><span class="s2"> _GAP $end</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_probe_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">bus_range_str</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">now</span> <span class="o">=</span> <span class="s2">&quot;{:%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="c1"># adjust for trigger position</span>
        <span class="n">hdr_1</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$date</span><span class="se">\n</span><span class="s2">        </span><span class="si">{</span><span class="n">now</span><span class="si">}</span><span class="se">\n</span><span class="s2">$end</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="n">hdr_2</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;$version</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;        ChipScoPy Version </span><span class="si">{</span><span class="n">chipscopy</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;$end</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;$timescale</span><span class="se">\n</span><span class="s2">        1ps</span><span class="se">\n</span><span class="s2">$end</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;$scope module dut $end</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">hdr_3</span> <span class="o">=</span> <span class="s2">&quot;$upscope $end</span><span class="se">\n</span><span class="s2">$enddefinitions $end</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">hdr_1</span> <span class="o">+</span> <span class="n">hdr_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_variable_definitions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">hdr_3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_position</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_index</span><span class="p">,</span>
        <span class="n">sample_in_window_index</span><span class="p">,</span>
        <span class="n">is_trigger</span><span class="p">,</span>
        <span class="n">probe_binary_reversed_values</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">is_last_sample</span><span class="p">,</span>
        <span class="n">is_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">time_written</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">write_value</span><span class="p">(</span><span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reversed_value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">nonlocal</span> <span class="n">time_written</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">time_written</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="n">sample_position</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">time_written</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reversed_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">reversed_value</span><span class="si">}{</span><span class="n">var</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="c1"># Remove leading zeroes</span>
            <span class="k">if</span> <span class="n">is_gap</span> <span class="ow">and</span> <span class="n">reversed_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">reversed_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Remove leading zeroes</span>
                <span class="n">msb_idx</span> <span class="o">=</span> <span class="n">reversed_value</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">msb_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msb_idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">reversed_value</span><span class="p">[</span><span class="n">msb_idx</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;b</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Write time, for last sample, even if no changes.</span>
        <span class="k">if</span> <span class="n">is_last_sample</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="n">sample_position</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">time_written</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Trigger value</span>
        <span class="k">if</span> <span class="n">is_trigger</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_trigger</span><span class="p">:</span>
            <span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trigger_var</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">is_trigger</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_trigger</span> <span class="o">=</span> <span class="n">is_trigger</span>

        <span class="c1"># Window marker.</span>
        <span class="k">if</span> <span class="n">window_index</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev_window_index</span><span class="p">:</span>
            <span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_var</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">window_index</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prev_window_index</span> <span class="o">=</span> <span class="n">window_index</span>

        <span class="c1"># gap value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_gap</span> <span class="ow">and</span> <span class="n">is_gap</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_gap</span><span class="p">:</span>
            <span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gap_var</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">is_gap</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prev_sample_is_gap</span> <span class="o">=</span> <span class="n">is_gap</span>

        <span class="c1"># Regular values</span>
        <span class="k">if</span> <span class="n">is_gap</span><span class="p">:</span>
            <span class="n">probe_binary_reversed_values</span> <span class="o">=</span> <span class="n">WaveformWriter</span><span class="o">.</span><span class="n">make_values_unknown</span><span class="p">(</span>
                <span class="n">probe_binary_reversed_values</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">new_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">probe_binary_reversed_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_val</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
            <span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">new_val</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">export_waveform_to_stream</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">ILAWaveform</span><span class="p">,</span>
    <span class="n">export_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">stream_handle</span><span class="p">:</span> <span class="n">TextIOBase</span><span class="p">,</span>
    <span class="n">probe_names</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Arguments documented in calling API function&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">probe_names</span><span class="p">:</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[</span><span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">p_name</span> <span class="ow">in</span> <span class="n">probe_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">probes</span><span class="p">):</span>
            <span class="n">bad_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">probe_names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;export_waveform() called with non-existent probe_name:</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">bad_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;CSV&quot;</span><span class="p">:</span>
        <span class="n">waveform_writer</span> <span class="o">=</span> <span class="n">WaveformWriterCSV</span><span class="p">(</span><span class="n">stream_handle</span><span class="p">,</span> <span class="n">probes</span><span class="p">,</span> <span class="n">include_gap</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">export_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;VCD&quot;</span><span class="p">:</span>
        <span class="n">waveform_writer</span> <span class="o">=</span> <span class="n">WaveformWriterVCD</span><span class="p">(</span><span class="n">stream_handle</span><span class="p">,</span> <span class="n">probes</span><span class="p">,</span> <span class="n">include_gap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;ILAWaveform.export_waveform() called with non-supported format &quot;</span><span class="si">{</span><span class="n">export_format</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
        <span class="p">)</span>
    <span class="n">_export_waveform</span><span class="p">(</span>
        <span class="n">waveform</span><span class="p">,</span>
        <span class="n">waveform_writer</span><span class="p">,</span>
        <span class="n">probes</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">,</span>
        <span class="s2">&quot;export_waveform()&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">get_waveform_data_values</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">ILAWaveform</span><span class="p">,</span>
    <span class="n">probe_names</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">include_trigger</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">include_sample_info</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">include_gap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Arguments documented in calling API function&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">probe_names</span><span class="p">:</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[</span><span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">p_name</span> <span class="ow">in</span> <span class="n">probe_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">probes</span><span class="p">):</span>
            <span class="n">bad_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">probe_names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;ILAWaveform.get_data() called with non-existent probe name(s):</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">bad_names</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="n">waveform_writer</span> <span class="o">=</span> <span class="n">WaveformWriterToDict</span><span class="p">(</span>
        <span class="n">probes</span><span class="p">,</span> <span class="n">include_trigger</span><span class="p">,</span> <span class="n">include_sample_info</span><span class="p">,</span> <span class="n">include_gap</span>
    <span class="p">)</span>
    <span class="n">_export_waveform</span><span class="p">(</span>
        <span class="n">waveform</span><span class="p">,</span>
        <span class="n">waveform_writer</span><span class="p">,</span>
        <span class="n">probes</span><span class="p">,</span>
        <span class="n">start_window_idx</span><span class="p">,</span>
        <span class="n">window_count</span><span class="p">,</span>
        <span class="n">start_sample_idx</span><span class="p">,</span>
        <span class="n">sample_count</span><span class="p">,</span>
        <span class="s2">&quot;ILAWaveform.get_data()&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">waveform_writer</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_export_waveform</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">ILAWaveform</span><span class="p">,</span>
    <span class="n">writer</span><span class="p">:</span> <span class="n">WaveformWriter</span><span class="p">,</span>
    <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">],</span>
    <span class="n">start_window_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">start_sample_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sample_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">calling_function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># It is at this point where W_events dissapears for whatever reason.</span>
    <span class="k">def</span> <span class="nf">get_sample_binary_values</span><span class="p">(</span><span class="n">sample_data</span><span class="p">:</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">sample_int_value</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s2">&quot;little&quot;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">reversed_bin_value</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sample_int_value</span><span class="si">:</span><span class="s2">0</span><span class="si">{</span><span class="n">waveform</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s2">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="n">probes</span><span class="p">:</span>
            <span class="c1"># Each probe value can be made up of multiple bit range slices.</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="n">reversed_bin_value</span><span class="p">[</span><span class="n">br</span><span class="o">.</span><span class="n">index</span> <span class="p">:</span> <span class="n">br</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">br</span><span class="o">.</span><span class="n">length</span><span class="p">]</span> <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">probe</span><span class="o">.</span><span class="n">map_range</span><span class="p">]</span>
            <span class="n">p_val</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">convert_to_display_values</span><span class="p">(</span><span class="n">bin_values</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">probes</span><span class="p">:</span> <span class="p">[</span><span class="n">ILAWaveformProbe</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert binary values to display values based on probe settings.&quot;&quot;&quot;</span>
        <span class="n">display_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">bin_val</span><span class="p">,</span> <span class="n">probe</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bin_values</span><span class="p">,</span> <span class="n">probes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">probe</span><span class="o">.</span><span class="n">display_radix</span> <span class="o">==</span> <span class="n">ILAProbeRadix</span><span class="o">.</span><span class="n">ENUM</span> <span class="ow">and</span> <span class="n">probe</span><span class="o">.</span><span class="n">enum_def</span><span class="p">:</span>
                <span class="c1"># Convert binary to integer</span>
                <span class="n">int_val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_val</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">bin_val</span> <span class="k">else</span> <span class="mi">0</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Get enum member</span>
                    <span class="n">enum_member</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">enum_def</span><span class="p">(</span><span class="n">int_val</span><span class="p">)</span>

                    <span class="c1"># Check if probe has display map for custom labels</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s2">&quot;_display_map&quot;</span><span class="p">):</span>
                        <span class="n">display_val</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">_display_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">enum_member</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">enum_member</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">display_val</span> <span class="o">=</span> <span class="n">enum_member</span><span class="o">.</span><span class="n">name</span>

                    <span class="n">display_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">display_val</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># Value not in enum, show as hex</span>
                    <span class="n">display_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;0x</span><span class="si">{</span><span class="n">int_val</span><span class="si">:</span><span class="s2">X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Keep binary value for non-enum probes</span>
                <span class="n">display_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">display_values</span>

    <span class="k">def</span> <span class="nf">is_gap</span><span class="p">(</span><span class="n">sample_high_byte</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">gap_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gap_index</span> <span class="ow">and</span> <span class="n">sample_high_byte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">gap_index</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">window_count</span><span class="p">:</span>
        <span class="n">window_count</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">get_window_count</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sample_count</span><span class="p">:</span>
        <span class="n">sample_count</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">window_size</span>

    <span class="n">w_size</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">window_size</span>
    <span class="n">max_window_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span> <span class="o">+</span> <span class="n">w_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">w_size</span>
    <span class="k">if</span> <span class="n">start_window_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">start_window_idx</span> <span class="o">&gt;=</span> <span class="n">max_window_count</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">calling_function</span><span class="si">}</span><span class="s1"> function argument start_window=&quot;</span><span class="si">{</span><span class="n">start_window_idx</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;must be in the range [0-</span><span class="si">{</span><span class="n">max_window_count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">start_sample_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">start_sample_idx</span> <span class="o">&gt;=</span> <span class="n">w_size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">calling_function</span><span class="si">}</span><span class="s1"> function argument &quot;start_sample=&quot;</span><span class="si">{</span><span class="n">start_sample_idx</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;must be in the range [0-</span><span class="si">{</span><span class="n">w_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_count</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sample_count</span> <span class="o">&gt;</span> <span class="n">w_size</span> <span class="o">-</span> <span class="n">start_sample_idx</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">calling_function</span><span class="si">}</span><span class="s1"> function argument &quot;sample_count=&quot;</span><span class="si">{</span><span class="n">sample_count</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;must be in the range [1-</span><span class="si">{</span><span class="n">w_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_sample_idx</span><span class="si">}</span><span class="s2">], &quot;</span>
            <span class="sa">f</span><span class="s1">&#39;since start_sample_idx=&quot;</span><span class="si">{</span><span class="n">start_sample_idx</span><span class="si">}</span><span class="s1">&quot;.&#39;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">window_count</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">window_count</span> <span class="o">&gt;</span> <span class="n">max_window_count</span> <span class="o">-</span> <span class="n">start_window_idx</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">calling_function</span><span class="si">}</span><span class="s1"> function argument &quot;window_count=&quot;</span><span class="si">{</span><span class="n">window_count</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;must be in the range [1-</span><span class="si">{</span><span class="n">max_window_count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_window_idx</span><span class="si">}</span><span class="s2">], &quot;</span>
            <span class="sa">f</span><span class="s1">&#39;since start_window_idx=&quot;</span><span class="si">{</span><span class="n">start_window_idx</span><span class="si">}</span><span class="s1">&quot;.&#39;</span>
        <span class="p">)</span>

    <span class="n">sample_byte_count</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">bytes_per_sample</span><span class="p">()</span>
    <span class="n">raw_samples</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">sample_is_gap</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">window_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_window_idx</span><span class="p">,</span> <span class="n">start_window_idx</span> <span class="o">+</span> <span class="n">window_count</span><span class="p">):</span>
        <span class="n">window_start_sample_idx</span> <span class="o">=</span> <span class="n">window_idx</span> <span class="o">*</span> <span class="n">w_size</span>
        <span class="n">trigger_sample_idx</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">[</span><span class="n">window_idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
            <span class="n">window_start_sample_idx</span> <span class="o">+</span> <span class="n">start_sample_idx</span><span class="p">,</span>
            <span class="n">window_start_sample_idx</span> <span class="o">+</span> <span class="n">start_sample_idx</span> <span class="o">+</span> <span class="n">sample_count</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">sample_idx</span> <span class="o">&gt;=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span><span class="p">:</span>
                <span class="c1"># last window is not full.</span>
                <span class="k">break</span>
            <span class="n">raw_sample_idx</span> <span class="o">=</span> <span class="n">sample_idx</span> <span class="o">*</span> <span class="n">sample_byte_count</span>
            <span class="n">raw_sample_idx_end</span> <span class="o">=</span> <span class="n">raw_sample_idx</span> <span class="o">+</span> <span class="n">sample_byte_count</span>
            <span class="n">sample_idx_in_window</span> <span class="o">=</span> <span class="n">sample_idx</span> <span class="o">-</span> <span class="n">window_start_sample_idx</span>
            <span class="n">bin_values</span> <span class="o">=</span> <span class="n">get_sample_binary_values</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">[</span><span class="n">raw_sample_idx</span><span class="p">:</span><span class="n">raw_sample_idx_end</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">gap_index</span><span class="p">:</span>
                <span class="n">sample_is_gap</span> <span class="o">=</span> <span class="n">is_gap</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">[</span><span class="n">raw_sample_idx_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">waveform</span><span class="o">.</span><span class="n">gap_index</span><span class="p">)</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write_sample</span><span class="p">(</span>
                <span class="n">sample_idx</span><span class="p">,</span>
                <span class="n">window_idx</span><span class="p">,</span>
                <span class="n">sample_idx_in_window</span><span class="p">,</span>
                <span class="n">sample_idx_in_window</span> <span class="o">==</span> <span class="n">trigger_sample_idx</span><span class="p">,</span>
                <span class="n">bin_values</span><span class="p">,</span>
                <span class="n">sample_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span><span class="p">,</span>
                <span class="n">sample_is_gap</span><span class="p">,</span>
            <span class="p">)</span>


<span class="n">WAVEFORM_ARCHIVE_VERSION</span> <span class="o">=</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">Waveform2StrEncoder</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">JSONEncoder</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">encode_map_range</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># Convert ILABitRange tuple to a dict, e.g. [{&quot;index&quot;: 0, &quot;length&quot;: 2}]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">elem</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ILABitRange</span><span class="p">)</span> <span class="k">else</span> <span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ILAWaveformProbe</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">Waveform2StrEncoder</span><span class="o">.</span><span class="n">encode_map_range</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">asdict</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ILABitRange</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ILAProbeRadix</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">EnumMeta</span><span class="p">):</span>
            <span class="c1"># Encode as 2-item list: [&lt;name&gt;, &lt;dict of enum value items&gt;]</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">{</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="p">)}</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">items</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">JSONEncoder</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">export_compressed_waveform</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">ILAWaveform</span><span class="p">,</span>
    <span class="n">filepath_or_buffer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">],</span>
    <span class="n">compression</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">compresslevel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">waveform_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;gap_index&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">gap_index</span><span class="p">,</span>
        <span class="s2">&quot;probes&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">probes</span><span class="p">,</span>
        <span class="s2">&quot;sample_count&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">sample_count</span><span class="p">,</span>
        <span class="s2">&quot;trigger_position&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">trigger_position</span><span class="p">,</span>
        <span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span>
        <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">json_str</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">waveform_dict</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Waveform2StrEncoder</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span>
        <span class="n">filepath_or_buffer</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="n">allowZip64</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
        <span class="n">compresslevel</span><span class="o">=</span><span class="n">compresslevel</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">zf</span><span class="p">:</span>
        <span class="n">zf</span><span class="o">.</span><span class="n">writestr</span><span class="p">(</span><span class="s2">&quot;waveform.cfg&quot;</span><span class="p">,</span> <span class="n">json_str</span><span class="p">)</span>
        <span class="n">zf</span><span class="o">.</span><span class="n">writestr</span><span class="p">(</span><span class="s2">&quot;waveform.data&quot;</span><span class="p">,</span> <span class="n">waveform</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">decode_waveform_from_json</span><span class="p">(</span><span class="n">json_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">in_data</span><span class="p">:</span> <span class="nb">bytearray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ILAWaveform</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">decode_map_range</span><span class="p">(</span><span class="n">in_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ILABitRange</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">ILABitRange</span><span class="p">(</span><span class="o">**</span><span class="n">dd</span><span class="p">)</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">in_range</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">decode_probe</span><span class="p">(</span><span class="n">probe_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">in_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ILAWaveformProbe</span><span class="p">:</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;map_range&quot;</span><span class="p">:</span>
                    <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">decode_map_range</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;display_radix&quot;</span><span class="p">:</span>
                    <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ILAProbeRadix</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;enum_def&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error reading ILA waveform probe &quot;</span><span class="si">{</span><span class="n">probe_name</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">ex</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">ILAWaveformProbe</span><span class="p">(</span><span class="o">**</span><span class="n">pd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">decode_probes</span><span class="p">(</span><span class="n">in_probes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ILAWaveformProbe</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">decode_probe</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">probe_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">probe_dict</span> <span class="ow">in</span> <span class="n">in_probes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># Decode waveform json string.</span>
    <span class="n">json_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">json_str</span><span class="p">))</span>
    <span class="n">wd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">wd</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_data</span>
    <span class="n">wd</span><span class="p">[</span><span class="s2">&quot;probes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decode_probes</span><span class="p">(</span><span class="n">json_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;probes&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">()))</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;probes&quot;</span><span class="p">]:</span>
            <span class="c1"># data and probes, handled above.</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;version&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">WAVEFORM_ARCHIVE_VERSION</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;waveform archive version &quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&quot; is not supported.&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;Only versions &quot;&lt;=</span><span class="si">{</span><span class="n">WAVEFORM_ARCHIVE_VERSION</span><span class="si">}</span><span class="s1">&quot; are supported.&#39;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">ILAWaveform</span><span class="p">(</span><span class="o">**</span><span class="n">wd</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">import_compressed_waveform</span><span class="p">(</span><span class="n">filepath_or_buffer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ILAWaveform</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">filepath_or_buffer</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">zf</span><span class="p">:</span>
        <span class="n">json_str</span> <span class="o">=</span> <span class="n">zf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;waveform.cfg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">zf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;waveform.data&quot;</span><span class="p">))</span>

    <span class="n">waveform</span> <span class="o">=</span> <span class="n">decode_waveform_from_json</span><span class="p">(</span><span class="n">json_str</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">waveform</span>


<span class="k">class</span> <span class="nc">ProbeDataMapper</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wraps ProbeData to map simple signal names to full probe names.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probe_data</span><span class="p">,</span> <span class="n">signal_mapping</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probe_data</span> <span class="o">=</span> <span class="n">probe_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span> <span class="o">=</span> <span class="n">signal_mapping</span>

    <span class="k">def</span> <span class="nf">rising_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">full_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_data</span><span class="o">.</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">full_name</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">both_asserted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig1</span><span class="p">,</span> <span class="n">sig2</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">full_sig1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">sig1</span><span class="p">)</span>
        <span class="n">full_sig2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sig2</span><span class="p">,</span> <span class="n">sig2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_data</span><span class="o">.</span><span class="n">both_asserted</span><span class="p">(</span><span class="n">full_sig1</span><span class="p">,</span> <span class="n">full_sig2</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">full_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_data</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">full_name</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright (C) 2021-2022, Xilinx, Inc., Copyright (C) 2022-2025, Advanced Micro Devices, Inc.
      <span class="lastupdated">Last updated on December 05, 2025.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>